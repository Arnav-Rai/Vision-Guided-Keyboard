<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard - User-Triggered Suggestion Scan V2 (Skip Last)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #282c34;
            color: #abb2bf;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .app-container {
            background-color: #353a40;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 450px; /* Adjusted for 6 keys + gaps approx */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls {
            margin-bottom: 20px;
            text-align: center;
        }

        #startButton {
            padding: 12px 25px;
            font-size: 1em;
            background-color: #61afef;
            color: #282c34;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #startButton:hover {
            background-color: #529bcf;
        }
        #startButton:disabled {
            background-color: #4a5058;
            color: #7f848e;
            cursor: not-allowed;
        }

        #loadingMessage, .status-text {
            margin-top: 10px;
            font-size: 0.9em;
            color: #98c379;
        }
        #eyeStatus {
            color: #e06c75; 
        }
         #modelStatus { 
            color: #c678dd; 
            font-size: 0.8em;
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px; /* Can be wider than keyboard */
            aspect-ratio: 16 / 9;
            border: 1px solid #4a5058;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            background-color: #21252b;
        }
        video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); 
            object-fit: cover;
        }
        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }

        #typedTextArea {
            width: 100%;
            max-width: 640px; /* Can be wider than keyboard */
            min-height: 60px;
            background-color: #21252b;
            border: 1px solid #4a5058;
            padding: 12px;
            margin-bottom: 20px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 1.3em;
            color: #d19a66;
            border-radius: 8px;
            line-height: 1.5;
        }

        #keyboardArea {
            margin-bottom: 15px;
            display: grid;
            gap: 8px; /* Gap between rows */
            width: 100%;
        }
        .keyboard-row {
            display: flex;
            gap: 8px; /* Gap between keys in a row */
            justify-content: center; 
        }
        .key {
            width: 55px; 
            height: 55px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1em; 
            font-weight: bold;
            cursor: default;
            user-select: none;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease, border-color 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0; 
        }
        .key.special-key { 
            background-color: #5c6370;
            font-size: 0.75em; 
        }
        .key.space-key { 
            width: 181px; /* (3 * 55px) + (2 * 8px gap) */
            font-size: 0.8em;
        }
        .key.backspace-key {
             width: 55px; 
        }
         .key.final-row-key { 
            width: 86.5px; 
         }

        .key.highlighted {
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .key.selection-pending { 
            background-color: #FFC107; 
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1); 
        }
        .suggestion.selection-pending {
            background-color: #FFC107;
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1);
        }
         .keyboard-row.selection-pending .key { 
            background-color: #FFC107 !important; 
            color: #21252b !important;
            border: 2px solid #FFA000 !important;
        }
        .key.cancel-option-pending { 
            background-color: #e06c75 !important; 
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
            transform: scale(1.1);
        }


        .row-highlighted .key {
            background-color: #61afef;
            color: #282c34;
            border-color: #529bcf;
        }
        .row-highlighted .key.highlighted {
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
        }
        .row-highlighted .key.cancel-option-pending { 
             background-color: #e06c75 !important;
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
        }


        #suggestionsArea {
            margin-bottom: 20px;
            display: flex;
            gap: 8px;
            height: 40px;
            justify-content: center;
        }
        .suggestion {
            padding: 0 15px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: 500;
            cursor: default;
            user-select: none;
            min-width: 90px;
            height: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease;
        }
        .suggestion.highlighted {
            background-color: #c678dd;
            color: #282c34;
            border-color: #b668cc;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
        .suggestion.personalized {
            border-left: 4px solid #61afef; 
            font-style: italic;
        }
        .suggestion.model-prediction { 
            border-left: 4px solid #98c379; 
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="controls">
            <button id="startButton">Start Camera</button>
            <p id="loadingMessage">Click 'Start Camera' and grant permissions.</p>
            <p class="status-text" id="statusText">Status: Idle</p>
            <p class="status-text" id="eyeStatus">EAR: N/A</p>
            <p class="status-text" id="modelStatus">Model: Not loaded</p>
        </div>

        <div class="video-container">
            <video id="input_video" autoplay muted playsinline></video>
            <canvas class="output_canvas" id="output_canvas"></canvas>
        </div>

        <div id="typedTextArea"></div>
        <div id="suggestionsArea"></div>
        <div id="keyboardArea"></div>
    </div>

    <script type="module">
        // DOM Elements
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const typedTextArea = document.getElementById('typedTextArea');
        const keyboardArea = document.getElementById('keyboardArea');
        const suggestionsArea = document.getElementById('suggestionsArea');
        const statusText = document.getElementById('statusText');
        const eyeStatusText = document.getElementById('eyeStatus');
        const modelStatusText = document.getElementById('modelStatus');
        const startButton = document.getElementById('startButton');
        const loadingMessage = document.getElementById('loadingMessage');

        // --- Configuration ---
        const FRAME_WIDTH = 640;
        const FRAME_HEIGHT = 360;

        let BASE_WORD_LIST = []; 
        let PERSONALIZED_WORD_LIST = {}; 
        const DEFAULT_FALLBACK_WORDS = ["HELLO", "WORLD", "YES", "NO", "PLEASE", "THANK", "YOU", "GOOD", "MORNING", "AFTERNOON", "EVENING", "HELP"]; 
        const MAX_SUGGESTIONS = 3; 
        const SUGGESTION_SKIP_TEXT = "[Skip]";
        
        const SUGGEST_KEY_CHAR = "[Sugg]"; 
        const SEARCH_KEY_CHAR = "[Srch]"; 
        const BACKSPACE_KEY_CHAR = "<-";
        const DELETE_KEY_CHAR = "DEL";
        const CANCEL_KEY_CHAR = "CNCL";
        const SPACE_KEY_CHAR = " "; 
        const SPACE_KEY_DISPLAY_TEXT = "SPACE"; 

        const KEYS_PER_ALPHABET_ROW = 6;
        const NUM_ALPHABET_ROWS = 4; 
        const SPECIAL_KEYS_FINAL_ROW = [SUGGEST_KEY_CHAR, SEARCH_KEY_CHAR, DELETE_KEY_CHAR, CANCEL_KEY_CHAR];

        const TRAVERSAL_INTERVAL = 0.8;
        const POST_SELECTION_PAUSE = 0.6;
        const INITIAL_DELAY = 1.0;
        const EAR_THRESHOLD = 0.25;
        const SELECTION_BLINK_MIN_FRAMES = 5;

        // State Variables
        let keyboardRows = [];
        let currentScanMode;
        let currentRowScanIndex = 0;
        let currentKeyScanIndexInRow = 0;
        let selectedRowIndex = -1; 
        let originalSelectedRowForKeyScan = -1; 
        let lastTraversalTime = performance.now();
        let typedText = "";
        let isPausedAfterSelection = false;
        let lastSelectionTime = 0;
        let initialDelayPassed = false;
        let startTime = performance.now();
        let currentSuggestionObjects = []; 
        let activeSuggestionListForScanning = []; 
        let eyeClosureFramesCount = 0;
        let isTraversalPausedForSelectionConsideration = false;
        let isOfferingKeyScanCancel = false; 
        let currentSuggestionIndex = 0; 

        let faceMesh;
        let camera;
        let audioCtx;

        let tfModel = null; 
        let tfModelLoaded = false;
        let charToIndex = {};
        let indexToChar = {};
        let modelSequenceLength = 20; 
        let modelVocabSize = 0; 

        const SCANNING_MODE_ROW = 0;
        const SCANNING_MODE_KEY = 1;
        const SCANNING_MODE_SUGGESTION = 2;
        const LEFT_EYE_INDICES = [362, 385, 387, 263, 373, 380];
        const RIGHT_EYE_INDICES = [33, 160, 158, 133, 153, 144];
        
        async function loadCharMappings() {
            try {
                const response = await fetch('./char_mappings.json'); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for char_mappings.json`);
                const mappings = await response.json();
                charToIndex = mappings.char_to_index; indexToChar = mappings.index_to_char;
                modelSequenceLength = mappings.sequence_length; modelVocabSize = mappings.vocab_size;
                console.log("Character mappings loaded successfully.");
                if (!charToIndex || !indexToChar || !modelSequenceLength || !modelVocabSize) throw new Error("Character mapping data incomplete.");
            } catch (error) { console.error("Could not load char_mappings.json:", error); modelStatusText.textContent = "Model: CharMap Error"; tfModelLoaded = false; }
        }

        async function loadTFModel() {
            if (Object.keys(charToIndex).length === 0) { modelStatusText.textContent = "Model: Not Loaded (No CharMap)"; return; }
            modelStatusText.textContent = "Model: Loading...";
            try {
                tfModel = await tf.loadLayersModel('./tfjs_model_output_directory/model.json');
                tfModelLoaded = true; modelStatusText.textContent = "Model: Loaded"; console.log("TF.js model loaded.");
                if (tfModel && modelSequenceLength > 0 && modelVocabSize > 0) {
                    console.log("Warming up model...");
                    const dummyInput = tf.tensor2d([new Array(modelSequenceLength).fill(0)], [1, modelSequenceLength], 'int32');
                    tfModel.predict(dummyInput).dispose(); dummyInput.dispose(); console.log("Model warmed up.");
                }
            } catch (error) { console.error("Error loading TF.js model:", error); modelStatusText.textContent = "Model: Error loading"; tfModelLoaded = false; }
        }

        async function getTFModelSuggestions(prefix) {
            if (!tfModelLoaded || !tfModel || !prefix || prefix.length === 0 || Object.keys(charToIndex).length === 0) return [];
            let currentGeneratedSequence = prefix.toLowerCase();
            const modelSuggestionsOutput = new Set();
            try {
                for (let i = 0; i < 7 && modelSuggestionsOutput.size < MAX_SUGGESTIONS ; i++) {
                    let inputChars = currentGeneratedSequence.slice(-modelSequenceLength).split('');
                    let inputIds = inputChars.map(char => charToIndex[char] || 0);
                    while (inputIds.length < modelSequenceLength) inputIds.unshift(0);
                    const inputTensor = tf.tensor2d([inputIds], [1, modelSequenceLength], 'int32');
                    let predictionTensor;
                    try {
                        predictionTensor = tfModel.predict(inputTensor);
                        const probabilities = await predictionTensor.data();
                        let predictedIndex = 0, maxProb = -1;
                        for (let j = 0; j < probabilities.length; j++) if (probabilities[j] > maxProb) { maxProb = probabilities[j]; predictedIndex = j; }
                        const predictedChar = indexToChar[predictedIndex];
                        if (!predictedChar || predictedChar === ' ') {
                            const potentialWord = currentGeneratedSequence.toUpperCase();
                            if (potentialWord.length > prefix.length && (BASE_WORD_LIST.includes(potentialWord) || PERSONALIZED_WORD_LIST[potentialWord])) modelSuggestionsOutput.add(potentialWord);
                            break;
                        }
                        currentGeneratedSequence += predictedChar;
                        const fullPotentialWord = currentGeneratedSequence.toUpperCase();
                        if (fullPotentialWord.length > prefix.length && (BASE_WORD_LIST.includes(fullPotentialWord) || PERSONALIZED_WORD_LIST[fullPotentialWord])) modelSuggestionsOutput.add(fullPotentialWord);
                        if (i === 0 && currentGeneratedSequence.length === prefix.length + 1) {
                            const shortCompletion = currentGeneratedSequence.toUpperCase();
                            if (BASE_WORD_LIST.includes(shortCompletion) || PERSONALIZED_WORD_LIST[shortCompletion]) modelSuggestionsOutput.add(shortCompletion);
                        }
                    } finally { inputTensor.dispose(); if (predictionTensor) predictionTensor.dispose(); }
                }
                return Array.from(modelSuggestionsOutput).map(text => ({ text, source: 'model' }));
            } catch (error) { console.error("Error during TF model prediction:", error); return []; }
        }

        async function loadWordLists() {
            try {
                const storedPersonalizedWords = localStorage.getItem('personalizedWordList');
                PERSONALIZED_WORD_LIST = storedPersonalizedWords ? JSON.parse(storedPersonalizedWords) : {};
            } catch (e) { PERSONALIZED_WORD_LIST = {}; }
            try {
                const response = await fetch('./common_words.txt'); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();
                BASE_WORD_LIST = text.split(/\r?\n/).map(word => word.trim().toUpperCase()).filter(word => word.length > 0);
                if (BASE_WORD_LIST.length === 0) BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS];
            } catch (error) { BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS]; }
        }

        function savePersonalizedWords() {
            try { localStorage.setItem('personalizedWordList', JSON.stringify(PERSONALIZED_WORD_LIST)); } 
            catch (e) { console.error("Error saving personalized words:", e); }
        }

        function learnWord(word) {
            if (!word || typeof word !== 'string' || word.length === 0) return;
            const upperWord = word.trim().toUpperCase();
            if (upperWord.length < 2 && !["A", "I"].includes(upperWord)) return;
            PERSONALIZED_WORD_LIST[upperWord] = (PERSONALIZED_WORD_LIST[upperWord] || 0) + 1;
            savePersonalizedWords();
        }

        function initAudio() {
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type = "key_action") {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                oscillator.type = 'square'; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.15);
            } catch (e) { console.error("Error playing sound:", type, e); }
        }

        function calculateDistance(p1, p2) {
            if (!p1 || !p2 || p1.x === undefined || p2.x === undefined) return 0.0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function calculateEAR(eyeLandmarks) {
            if (!eyeLandmarks || eyeLandmarks.length !== 6) return 0.6;
            for(let lm of eyeLandmarks) if(!lm || lm.x === undefined || lm.y === undefined) return 0.6;
            const v1 = calculateDistance(eyeLandmarks[1], eyeLandmarks[5]);
            const v2 = calculateDistance(eyeLandmarks[2], eyeLandmarks[4]);
            const h1 = calculateDistance(eyeLandmarks[0], eyeLandmarks[3]);
            return h1 <= 1e-6 ? 0.6 : (v1 + v2) / (2.0 * h1);
        }

        function generateKeyboardLayout() {
            keyboardRows = [];
            keyboardArea.innerHTML = '';
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
            let letterIdx = 0;

            for (let r = 0; r < NUM_ALPHABET_ROWS; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row'; rowDiv.id = `kb-row-${r}`;
                let currentLayoutRow = [];
                for (let i = 0; i < KEYS_PER_ALPHABET_ROW; i++) {
                    if (letterIdx < 24) { 
                        const char = letters[letterIdx++];
                        const keyDiv = document.createElement('div'); keyDiv.className = 'key'; keyDiv.id = `key-${r}-${i}`; keyDiv.textContent = char;
                        rowDiv.appendChild(keyDiv); currentLayoutRow.push({ char: char, element: keyDiv, row: r, col: i });
                    }
                }
                keyboardRows.push(currentLayoutRow); keyboardArea.appendChild(rowDiv);
            }

            const row5Div = document.createElement('div'); row5Div.className = 'keyboard-row'; row5Div.id = `kb-row-${NUM_ALPHABET_ROWS}`;
            let row5Layout = [];
            const row5KeyDefinitions = [
                { char: letters[24], display: letters[24], class: 'key' }, // Y
                { char: letters[25], display: letters[25], class: 'key' }, // Z
                { char: SPACE_KEY_CHAR, display: SPACE_KEY_DISPLAY_TEXT, class: 'key space-key' },
                { char: BACKSPACE_KEY_CHAR, display: BACKSPACE_KEY_CHAR, class: 'key backspace-key special-key' }
            ];
            row5KeyDefinitions.forEach((keyDef, i) => {
                const keyDiv = document.createElement('div'); keyDiv.className = keyDef.class; keyDiv.id = `key-${NUM_ALPHABET_ROWS}-${i}`; keyDiv.textContent = keyDef.display;
                row5Div.appendChild(keyDiv); row5Layout.push({ char: keyDef.char, element: keyDiv, row: NUM_ALPHABET_ROWS, col: i });
            });
            keyboardRows.push(row5Layout); keyboardArea.appendChild(row5Div);

            const row6Div = document.createElement('div'); row6Div.className = 'keyboard-row'; row6Div.id = `kb-row-${NUM_ALPHABET_ROWS + 1}`;
            let row6Layout = [];
            SPECIAL_KEYS_FINAL_ROW.forEach((char, i) => {
                const keyDiv = document.createElement('div'); keyDiv.className = 'key special-key final-row-key'; keyDiv.id = `key-${NUM_ALPHABET_ROWS + 1}-${i}`; keyDiv.textContent = char;
                row6Div.appendChild(keyDiv); row6Layout.push({ char: char, element: keyDiv, row: NUM_ALPHABET_ROWS + 1, col: i });
            });
            keyboardRows.push(row6Layout); keyboardArea.appendChild(row6Div);
        }
        
        function updateKeyboardHighlight() {
            keyboardRows.forEach((row, rIdx) => {
                const rowDiv = document.getElementById(`kb-row-${rIdx}`);
                if (rowDiv) { rowDiv.classList.remove('row-highlighted', 'selection-pending'); }
                if(row) row.forEach(key => key.element.classList.remove('highlighted', 'selection-pending', 'cancel-option-pending'));
            });
            suggestionsArea.querySelectorAll('.suggestion').forEach(sugg => sugg.classList.remove('highlighted', 'selection-pending', 'personalized', 'model-prediction'));

            if (!initialDelayPassed || isPausedAfterSelection) return;

            let elementToMark = null; 
            let suggestionSource = null; 
            let isCancelOption = false;

            if (currentScanMode === SCANNING_MODE_ROW && keyboardRows[currentRowScanIndex]) {
                const rowDiv = document.getElementById(`kb-row-${currentRowScanIndex}`);
                if (rowDiv) rowDiv.classList.add(isTraversalPausedForSelectionConsideration ? 'selection-pending' : 'row-highlighted');
            } else if (currentScanMode === SCANNING_MODE_KEY) {
                if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                    elementToMark = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].element;
                    if (isOfferingKeyScanCancel && keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].char === CANCEL_KEY_CHAR) {
                        isCancelOption = true;
                    }
                }
            } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                const suggestions = suggestionsArea.querySelectorAll('.suggestion');
                if (typeof currentSuggestionIndex !== 'number' || isNaN(currentSuggestionIndex)) currentSuggestionIndex = 0;
                if (suggestions[currentSuggestionIndex] && activeSuggestionListForScanning?.[currentSuggestionIndex]) {
                    elementToMark = suggestions[currentSuggestionIndex];
                    suggestionSource = activeSuggestionListForScanning[currentSuggestionIndex].source;
                }
            }

            if (elementToMark) {
                if (isCancelOption) elementToMark.classList.add('cancel-option-pending');
                else if (isTraversalPausedForSelectionConsideration) elementToMark.classList.add('selection-pending');
                else elementToMark.classList.add('highlighted');
                if (suggestionSource === 'personalized') elementToMark.classList.add('personalized');
                else if (suggestionSource === 'model') elementToMark.classList.add('model-prediction');
            }
        }

        function getPersonalizedSuggestions(prefix) {
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            return Object.entries(PERSONALIZED_WORD_LIST)
                .filter(([word]) => word.toLowerCase().startsWith(prefixLower))
                .map(([text, frequency]) => ({ text, frequency, source: 'personalized' })) 
                .sort((a, b) => b.frequency - a.frequency);
        }

        async function getCombinedSuggestions(prefix) { 
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            let combined = [];
            const addedTexts = new Set(); 

            const personalized = getPersonalizedSuggestions(prefixLower);
            personalized.forEach(sugg => {
                if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                    combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                }
            });

            if (combined.length < MAX_SUGGESTIONS && tfModelLoaded) {
                const modelSuggestions = await getTFModelSuggestions(prefixLower); 
                modelSuggestions.forEach(sugg => {
                    if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                        combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                    }
                });
            }
            
            if (combined.length < MAX_SUGGESTIONS) {
                for (const word of BASE_WORD_LIST) {
                    if (combined.length >= MAX_SUGGESTIONS) break;
                    if (word.toLowerCase().startsWith(prefixLower) && !addedTexts.has(word.toLowerCase())) {
                        combined.push({ text: word, source: 'base' }); addedTexts.add(word.toLowerCase());
                    }
                }
            }
            return combined.slice(0, MAX_SUGGESTIONS); 
        }

        function displaySuggestions() { 
            suggestionsArea.innerHTML = '';
            const listToDisplay = (currentScanMode === SCANNING_MODE_SUGGESTION) ? activeSuggestionListForScanning : currentSuggestionObjects;
            if (!listToDisplay || listToDisplay.length === 0) {
                suggestionsArea.innerHTML = ''; updateKeyboardHighlight(); return;
            }
            listToDisplay.forEach(suggObj => {
                const suggDiv = document.createElement('div'); suggDiv.className = 'suggestion';
                suggDiv.textContent = suggObj.text; 
                if (suggObj.source === 'personalized') suggDiv.classList.add('personalized');
                else if (suggObj.source === 'model') suggDiv.classList.add('model-prediction');
                suggestionsArea.appendChild(suggDiv);
            });
            updateKeyboardHighlight();
        }

        function resetToRowScan() {
            currentScanMode = SCANNING_MODE_ROW; currentRowScanIndex = 0; selectedRowIndex = -1; originalSelectedRowForKeyScan = -1;
            currentKeyScanIndexInRow = 0; activeSuggestionListForScanning = []; currentSuggestionIndex = 0; 
            lastTraversalTime = performance.now(); 
            isTraversalPausedForSelectionConsideration = false; isOfferingKeyScanCancel = false;
            eyeClosureFramesCount = 0;
            statusText.textContent = "Status: Row Scanning"; 
            // currentSuggestionObjects are kept for passive display until next letter typed or action
            displaySuggestions(); 
        }

        function onResults(results) {
            const currentTime = performance.now();
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            let selectionTriggeredThisFrame = false;
            let avgEar = 0.6; 

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const leftEyeLms = LEFT_EYE_INDICES.map(i => landmarks[i]);
                const rightEyeLms = RIGHT_EYE_INDICES.map(i => landmarks[i]);
                const leftEar = calculateEAR(leftEyeLms);
                const rightEar = calculateEAR(rightEyeLms);
                avgEar = (leftEar + rightEar) / 2.0;
                eyeStatusText.textContent = `EAR: ${avgEar.toFixed(2)}${isTraversalPausedForSelectionConsideration ? ` (Paused - ${eyeClosureFramesCount})` : ""}`;

                if (avgEar < EAR_THRESHOLD) { 
                    if (initialDelayPassed && !isPausedAfterSelection) { 
                        isTraversalPausedForSelectionConsideration = true; eyeClosureFramesCount++;
                    }
                } else { 
                    if (isTraversalPausedForSelectionConsideration) { 
                        if (eyeClosureFramesCount >= SELECTION_BLINK_MIN_FRAMES) {
                            if (!isPausedAfterSelection && initialDelayPassed) selectionTriggeredThisFrame = true;
                        }
                        eyeClosureFramesCount = 0; isTraversalPausedForSelectionConsideration = false;
                    }
                }
            } else { 
                eyeStatusText.textContent = "EAR: N/A (No face detected)";
                eyeClosureFramesCount = 0; isTraversalPausedForSelectionConsideration = false;
                if(isOfferingKeyScanCancel) { isOfferingKeyScanCancel = false; resetToRowScan(); }
            }

            if (isPausedAfterSelection && (currentTime - lastSelectionTime) / 1000 >= POST_SELECTION_PAUSE) {
                isPausedAfterSelection = false; lastTraversalTime = currentTime;
            }

            if (!initialDelayPassed) {
                const elapsed = (currentTime - startTime) / 1000;
                statusText.textContent = `Status: Initializing... (${(INITIAL_DELAY - elapsed).toFixed(1)}s)`;
                if (elapsed >= INITIAL_DELAY) { initialDelayPassed = true; lastTraversalTime = currentTime; resetToRowScan(); }
            } else if (!isPausedAfterSelection) { 
                if (selectionTriggeredThisFrame) {
                    lastSelectionTime = currentTime; isPausedAfterSelection = true;
                    isTraversalPausedForSelectionConsideration = false; eyeClosureFramesCount = 0;

                    if (currentScanMode === SCANNING_MODE_ROW) {
                        if (keyboardRows[currentRowScanIndex]) {
                            selectedRowIndex = currentRowScanIndex; originalSelectedRowForKeyScan = currentRowScanIndex; 
                            currentScanMode = SCANNING_MODE_KEY; currentKeyScanIndexInRow = 0;
                            isOfferingKeyScanCancel = false; 
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; playSound("row_select");
                        }
                    } else if (currentScanMode === SCANNING_MODE_KEY) {
                        if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                            const keyInfo = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow];
                            const char = keyInfo.char; 
                            playSound("key_action");
                            let wordToLearn = null;

                            if (isOfferingKeyScanCancel && char === CANCEL_KEY_CHAR) {
                                resetToRowScan(); 
                            } else {
                                isOfferingKeyScanCancel = false; 
                                if (char === BACKSPACE_KEY_CHAR) { typedText = typedText.slice(0, -1); currentSuggestionObjects = []; displaySuggestions(); resetToRowScan(); } 
                                else if (char === SPACE_KEY_CHAR) { 
                                    const w = typedText.trim().split(/\s+/); if (w.length > 0 && w[w.length-1]) wordToLearn = w[w.length-1]; 
                                    typedText += " "; currentSuggestionObjects = []; displaySuggestions(); resetToRowScan();
                                } 
                                else if (char === SEARCH_KEY_CHAR) { if (typedText) window.open(`https://www.google.com/search?q=${encodeURIComponent(typedText)}`, '_blank'); currentSuggestionObjects = []; displaySuggestions(); resetToRowScan();} 
                                else if (char === CANCEL_KEY_CHAR) { currentSuggestionObjects = []; displaySuggestions(); resetToRowScan(); } 
                                else if (char === DELETE_KEY_CHAR) { const ls = typedText.trimEnd().lastIndexOf(' '); typedText = (ls !== -1) ? typedText.substring(0, ls + 1) : ""; currentSuggestionObjects = []; displaySuggestions(); resetToRowScan();}
                                else if (char === SUGGEST_KEY_CHAR) { 
                                    activeSuggestionListForScanning = [...currentSuggestionObjects]; 
                                    activeSuggestionListForScanning.push({text: SUGGESTION_SKIP_TEXT, source: 'system'}); // Add [Skip] as the last item
                                    currentScanMode = SCANNING_MODE_SUGGESTION; currentSuggestionIndex = 0;
                                    statusText.textContent = "Status: Suggestion Scanning"; 
                                    displaySuggestions(); // Update UI for scanning suggestions
                                }
                                else { // Regular character
                                    typedText += char; 
                                    const prefix = typedText.match(/([^\s]+)$/)?.[0];
                                    if (prefix) {
                                        getCombinedSuggestions(prefix).then(suggestions => { 
                                            currentSuggestionObjects = suggestions; displaySuggestions(); 
                                        }).catch(err => { currentSuggestionObjects = []; displaySuggestions(); });
                                    } else { currentSuggestionObjects = []; displaySuggestions(); }
                                    resetToRowScan(); 
                                }
                                if(wordToLearn) learnWord(wordToLearn); 
                                typedTextArea.textContent = typedText;
                                statusText.textContent = `Action: ${keyInfo.element.textContent}`; 
                            }
                        } else { resetToRowScan(); }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                         if (activeSuggestionListForScanning?.[currentSuggestionIndex]) { 
                            const item = activeSuggestionListForScanning[currentSuggestionIndex].text; playSound("suggestion_select");
                            if (item !== SUGGESTION_SKIP_TEXT) {
                                const ls = typedText.lastIndexOf(' '); typedText = (ls === -1 ? "" : typedText.substring(0, ls + 1)) + item + " ";
                                typedTextArea.textContent = typedText; learnWord(item);
                            } statusText.textContent = `Suggestion: ${item}`; 
                            currentSuggestionObjects = []; 
                            resetToRowScan();
                        } else { resetToRowScan(); }
                    }
                } 
                else if (!isTraversalPausedForSelectionConsideration && (currentTime - lastTraversalTime) / 1000 >= TRAVERSAL_INTERVAL) {
                    if (currentScanMode === SCANNING_MODE_ROW) {
                        currentRowScanIndex = (currentRowScanIndex + 1) % keyboardRows.length;
                        statusText.textContent = "Status: Row Scanning";
                    } else if (currentScanMode === SCANNING_MODE_KEY) {
                        if (isOfferingKeyScanCancel) { 
                            isOfferingKeyScanCancel = false; selectedRowIndex = originalSelectedRowForKeyScan; 
                            currentKeyScanIndexInRow = 0; 
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                        } else {
                            currentKeyScanIndexInRow++;
                            if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex] && currentKeyScanIndexInRow >= keyboardRows[selectedRowIndex].length) {
                                isOfferingKeyScanCancel = true; originalSelectedRowForKeyScan = selectedRowIndex; 
                                selectedRowIndex = keyboardRows.length - 1; // Last row (special keys)
                                const cancelKeyObj = keyboardRows[selectedRowIndex].find(key => key.char === CANCEL_KEY_CHAR);
                                currentKeyScanIndexInRow = cancelKeyObj ? keyboardRows[selectedRowIndex].indexOf(cancelKeyObj) : 0;
                                statusText.textContent = "Status: Cancel Key Scan?";
                            } else if (selectedRowIndex == -1 || !keyboardRows[selectedRowIndex]) { resetToRowScan(); 
                            } else { statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; }
                        }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                        if (activeSuggestionListForScanning?.length > 0) currentSuggestionIndex = (currentSuggestionIndex + 1) % activeSuggestionListForScanning.length;
                        else resetToRowScan(); 
                        statusText.textContent = "Status: Suggestion Scanning";
                    }
                    lastTraversalTime = currentTime;
                } else if (isTraversalPausedForSelectionConsideration && !statusText.textContent.includes("Evaluating")) {
                    statusText.textContent = "Status: Evaluating Blink...";
                } else if (!isTraversalPausedForSelectionConsideration && !isOfferingKeyScanCancel && !statusText.textContent.startsWith("Status: Initializing") && !statusText.textContent.startsWith("Action:") && !statusText.textContent.startsWith("Suggestion:")) {
                     if (currentScanMode === SCANNING_MODE_ROW) statusText.textContent = "Status: Row Scanning";
                     else if (currentScanMode === SCANNING_MODE_KEY && selectedRowIndex !== -1) statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                     else if (currentScanMode === SCANNING_MODE_SUGGESTION && activeSuggestionListForScanning?.length > 0) statusText.textContent = "Status: Suggestion Scanning";
                     else if (currentScanMode === SCANNING_MODE_SUGGESTION ) statusText.textContent = "Status: Row Scanning"; 
                }
            }

            updateKeyboardHighlight();
            canvasCtx.restore();
        }

        async function startApp() {
            currentSuggestionIndex = 0; 
            await loadWordLists(); 
            await loadCharMappings(); 
            await loadTFModel();    
            initAudio();
            startButton.disabled = true; startButton.textContent = "Loading...";
            loadingMessage.textContent = "Initializing MediaPipe..."; loadingMessage.style.display = 'block';
            try {
                faceMesh = new FaceMesh({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                faceMesh.onResults(onResults);
                videoElement.onloadedmetadata = () => { canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight; };
                if (typeof Camera === "undefined") throw new Error("Camera utility not loaded.");
                camera = new Camera(videoElement, { onFrame: async () => { if (videoElement.readyState >= 2) await faceMesh.send({image: videoElement}); }, width: FRAME_WIDTH, height: FRAME_HEIGHT });
                await camera.start();
                loadingMessage.textContent = "Camera started. Calibrating..."; statusText.textContent = "Status: Camera Active";
                if (videoElement.videoWidth > 0 && (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight) ) {
                    canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
                }
                startTime = performance.now(); initialDelayPassed = false;
                generateKeyboardLayout(); resetToRowScan();
            } catch (err) {
                console.error("Error during startApp:", err);
                loadingMessage.textContent = `Error: ${err.message}. Check console & permissions.`;
                statusText.textContent = "Status: Error";
                modelStatusText.textContent = "Model: Error";
                startButton.disabled = false; startButton.textContent = "Start Camera";
            }
        }
        startButton.addEventListener('click', startApp);
    </script>
</body>
</html>
