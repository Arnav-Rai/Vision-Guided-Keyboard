<!DOCTYPE html>
<html lang="en">
<head>
    <!--3-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard - User-Triggered Suggestion Scan V18 (Contextual Cancel)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #282c34;
            color: #abb2bf;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .app-container {
            background-color: #353a40;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 450px; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls {
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
        }
        
        .control-buttons-container {
            display: flex;
            justify-content: space-around; 
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
        }


        #startButton, #switchInputModeButton { 
            padding: 10px 15px; 
            font-size: 0.85em; 
            background-color: #61afef;
            color: #282c34;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 150px; 
            white-space: normal; 
            line-height: 1.3;
            margin: 5px;
        }
        #startButton:hover, #switchInputModeButton:hover {
            background-color: #529bcf;
        }
        #startButton:disabled, #switchInputModeButton:disabled { 
            background-color: #4a5058;
            color: #7f848e;
            cursor: not-allowed;
        }


        #loadingMessage, .status-text {
            margin-top: 10px;
            font-size: 0.9em;
            color: #98c379;
            min-height: 1.2em; 
        }
        #eyeStatus {
            color: #e06c75;
        }
         #modelStatus {
            color: #c678dd;
            font-size: 0.8em;
        }
        #calibrationInstructions {
            margin-top: 15px;
            padding: 10px;
            background-color: #4a5058;
            border-radius: 6px;
            font-size: 0.95em;
            color: #e5c07b; 
            text-align: center;
            display: none; 
        }
        #emailSetupInstructions {
            margin-top: 5px;
            font-size: 0.85em;
            color: #e5c07b; 
            min-height: 1em;
        }


        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            aspect-ratio: 16 / 9;
            border: 1px solid #4a5058;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            background-color: #21252b;
        }
        video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }
        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }

        #typedTextArea {
            width: 100%;
            max-width: 640px;
            min-height: 60px;
            background-color: #21252b;
            border: 1px solid #4a5058;
            padding: 12px;
            margin-bottom: 20px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 1.3em;
            color: #d19a66;
            border-radius: 8px;
            line-height: 1.5;
        }

        #keyboardArea {
            margin-bottom: 15px;
            display: grid;
            gap: 8px;
            width: 100%;
        }
        .keyboard-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        .key {
            width: 55px;
            height: 55px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1em;
            font-weight: bold;
            cursor: default; 
            user-select: none;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease, border-color 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        .key.clickable:hover { 
            background-color: #5c6370;
            border-color: #529bcf;
        }
        .key.clickable:active { 
            transform: scale(0.95);
            background-color: #61afef;
        }

        .key.special-key {
            background-color: #5c6370;
            font-size: 0.75em; 
            padding: 0 3px; 
            line-height: 1.2; 
            text-align: center;
            word-break: keep-all; 
        }
        .key.email-action-key { 
            width: 150px; 
            height: 55px;
            font-size: 0.9em;
            margin: 10px;
        }


        .key.backspace-key {
             width: 55px;
        }
         .key.final-row-key { 
            width: 67px; 
         }
         .key.number-key, .key.punctuation-key { 
            font-size: 1.1em; 
         }


        .key.highlighted { 
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .key.selection-pending { 
            background-color: #FFC107;
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1);
        }
        .suggestion.selection-pending {
            background-color: #FFC107;
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1);
        }
         .keyboard-row.selection-pending .key { 
            background-color: #FFC107 !important;
            color: #21252b !important;
            border: 2px solid #FFA000 !important;
        }
        .key.cancel-option-pending { 
            background-color: #e06c75 !important;
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
            transform: scale(1.1);
        }


        .row-highlighted .key {
            background-color: #61afef;
            color: #282c34;
            border-color: #529bcf;
        }
        .row-highlighted .key.highlighted { 
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
        }
        .row-highlighted .key.cancel-option-pending { 
             background-color: #e06c75 !important;
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
        }


        #suggestionsArea {
            margin-bottom: 20px;
            display: flex;
            gap: 8px;
            height: 40px;
            justify-content: center;
        }
        .suggestion {
            padding: 0 15px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: 500;
            cursor: default; 
            user-select: none;
            min-width: 90px;
            height: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease;
        }
        .suggestion.highlighted { 
            background-color: #c678dd;
            color: #282c34;
            border-color: #b668cc;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
        .suggestion.personalized {
            border-left: 4px solid #61afef;
            font-style: italic;
        }
        .suggestion.model-prediction {
            border-left: 4px solid #98c379;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="controls">
            <div class="control-buttons-container">
                <button id="startButton">Start Camera</button>
                <button id="switchInputModeButton">Use Click Input</button>
            </div>
            <p id="loadingMessage">Click 'Start Camera' or wait for auto-start.</p>
            <p id="calibrationInstructions">Please blink slowly three times.</p>
            <p id="emailSetupInstructions"></p> 
            <p class="status-text" id="statusText">Status: Idle</p>
            <p class="status-text" id="eyeStatus">EAR: N/A</p>
            <p class="status-text" id="modelStatus">Model: Not loaded</p>
        </div>

        <div class="video-container">
            <video id="input_video" autoplay muted playsinline></video>
            <canvas class="output_canvas" id="output_canvas"></canvas>
        </div>

        <div id="typedTextArea"></div>
        <div id="suggestionsArea"></div>
        <div id="keyboardArea"></div>
    </div>

    <script type="module">
        // DOM Elements
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const typedTextArea = document.getElementById('typedTextArea');
        const keyboardArea = document.getElementById('keyboardArea');
        const suggestionsArea = document.getElementById('suggestionsArea');
        const statusText = document.getElementById('statusText');
        const eyeStatusText = document.getElementById('eyeStatus');
        const modelStatusText = document.getElementById('modelStatus');
        const startButton = document.getElementById('startButton');
        const switchInputModeButton = document.getElementById('switchInputModeButton');
        const loadingMessage = document.getElementById('loadingMessage');
        const calibrationInstructions = document.getElementById('calibrationInstructions');
        const emailSetupInstructions = document.getElementById('emailSetupInstructions');


        // --- Configuration ---
        const FRAME_WIDTH = 640;
        const FRAME_HEIGHT = 360;

        let BASE_WORD_LIST = [];
        let PERSONALIZED_WORD_LIST = {};
        const DEFAULT_FALLBACK_WORDS = ["HELLO", "WORLD", "YES", "NO", "PLEASE", "THANK", "YOU", "GOOD", "MORNING", "AFTERNOON", "EVENING", "HELP"];
        const MAX_SUGGESTIONS = 3;
        const SUGGESTION_SKIP_TEXT = "[Skip]"; 

        const SUGGEST_KEY_CHAR = "Suggest"; 
        const SEARCH_KEY_CHAR = "Search";  
        const MAIL_KEY_CHAR = "Mail";     
        const BACKSPACE_KEY_CHAR = "<-";
        const DELETE_KEY_CHAR = "DEL";      
        const CANCEL_KEY_CHAR = "CNCL";     // Generic cancel, e.g., for row scan
        const SPACE_KEY_CHAR = " ";
        const SPACE_KEY_DISPLAY_TEXT = "SPACE";
        const NUM_KEY_CHAR = "Num";       
        const PUNC_KEY_CHAR = "[,.]";      

        // Email Setup Keys
        const SENDER_EMAIL_ADDRESS = "arnavrai03@gmail.com"; 
        const EMAIL_NEXT_FIELD_KEY = "Next"; 
        const EMAIL_SEND_KEY = "Send Mail";
        const EMAIL_CANCEL_SETUP_KEY = "Cancel Mail"; // Specific to cancelling the entire email process
        const EMAIL_DOMAIN_SUFFIX = "@gmail.com";


        const NUMBERS_LAYOUT_CONFIG = { chars: "1234567890".split(''), type: 'number' };
        const PUNCTUATION_LAYOUT_CONFIG = { chars: ",.@?!'".split(''), type: 'punctuation' };


        const KEYS_PER_ALPHABET_ROW = 6;
        const NUM_ALPHABET_ROWS = 4; 
        const DEFAULT_SPECIAL_KEYS_FINAL_ROW_CHARS = [SUGGEST_KEY_CHAR, SEARCH_KEY_CHAR, MAIL_KEY_CHAR, DELETE_KEY_CHAR, CANCEL_KEY_CHAR];
        const EMAIL_SETUP_FINAL_ROW_CHARS = [EMAIL_NEXT_FIELD_KEY, BACKSPACE_KEY_CHAR, DELETE_KEY_CHAR, EMAIL_CANCEL_SETUP_KEY];


        const TRAVERSAL_INTERVAL = 0.8; 
        const POST_SELECTION_PAUSE = 0.6; 
        const INITIAL_DELAY = 1.0; 
        let minEarThreshold = 0.25; 
        const INITIAL_EAR_FOR_CALIBRATION_DETECTION = 0.20;
        const CALIBRATION_BLINK_MIN_FRAMES_LOW = 2;
        const CALIBRATION_BLINK_MIN_FRAMES_HIGH = 2;
        const SELECTION_BLINK_MIN_FRAMES = 2; 

        // State Variables
        let keyboardRows = []; 
        let currentScanMode;
        let currentRowScanIndex = 0;
        let currentKeyScanIndexInRow = 0; 
        let selectedRowIndex = -1; 
        let originalSelectedRowForKeyScan = -1; 
        let lastTraversalTime = performance.now();
        let typedText = ""; 
        let isPausedAfterSelection = false;
        let lastSelectionTime = 0;
        let initialDelayPassed = false;
        let startTime = performance.now();
        let currentSuggestionObjects = [];
        let activeSuggestionListForScanning = [];
        let eyeClosureFramesCount = 0;
        let isTraversalPausedForSelectionConsideration = false;
        let isOfferingKeyScanCancel = false; // True when the generic CNCL is offered after a character row scan
        let currentSuggestionIndex = 0;

        let faceMesh;
        let camera;
        let audioCtx;
        let isCameraActive = false; 

        let tfModel = null;
        let tfModelLoaded = false;
        let charToIndex = {};
        let indexToChar = {};
        let modelSequenceLength = 20;
        let modelVocabSize = 0;

        // Calibration State
        let isCalibrating = false;
        let calibrationBlinksNeeded = 3;
        let calibrationEarValues = [];
        let calibrationState = "idle";
        let calibrationFramesLowCount = 0;
        let calibrationFramesHighCount = 0;
        let currentCalibrationBlinkMinEar = 1.0;

        // Auto-start State
        let autoStartTimerId = null;
        let autoStartCountdown = 2; 
        const AUTO_START_INTERVAL = 1000; 
        let isAutoStartActive = false; 
        let isAutoStartPaused = false; 

        // Input Mode State
        let inputMethod = "blink"; 


        // Special Keyboard State (Num/Punc)
        let activeSpecialKeyboardType = null; 
        let specialKeyboardRowElements = []; 

        // Email Setup State
        let isSettingUpEmail = false;
        let emailSetupPhase = ""; 
        let receiverEmailUsername = ""; 
        let originalTypedTextBeforeEmail = ""; 
        let isOfferingGenericCancelForEmailRow = false; // New flag

        const SCANNING_MODE_ROW = 0;
        const SCANNING_MODE_KEY = 1; 
        const SCANNING_MODE_SUGGESTION = 2;
        const SCANNING_MODE_SPECIAL_ROW = 3; 
        const SCANNING_MODE_EMAIL_SETUP = 4; 

        const LEFT_EYE_INDICES = [362, 385, 387, 263, 373, 380];
        const RIGHT_EYE_INDICES = [33, 160, 158, 133, 153, 144];

        // --- Auto-start Camera Logic ---
        function startAutoStartTimer() { /* ... (implementation unchanged) ... */ 
            if (autoStartTimerId) clearInterval(autoStartTimerId); 
            isAutoStartActive = true;
            isAutoStartPaused = false;
            autoStartCountdown = 2; 
            startButton.textContent = `Starting in ${autoStartCountdown}s... (Click to Pause)`;
            startButton.disabled = false; 

            autoStartTimerId = setInterval(() => {
                autoStartCountdown--;
                if (autoStartCountdown > 0) {
                    startButton.textContent = `Starting in ${autoStartCountdown}s... (Click to Pause)`;
                } else {
                    clearInterval(autoStartTimerId);
                    autoStartTimerId = null;
                    isAutoStartActive = false;
                    startButton.textContent = "Starting..."; 
                    startButton.disabled = true;
                    startApp(); 
                }
            }, AUTO_START_INTERVAL);
        }
        function stopAutoStartTimer() { /* ... (implementation unchanged) ... */ 
            if (autoStartTimerId) {
                clearInterval(autoStartTimerId);
                autoStartTimerId = null;
            }
            isAutoStartActive = false;
        }

        // --- Model Loading & Word Lists ---
        async function loadCharMappings() { /* ... (implementation unchanged) ... */ 
            try {
                const response = await fetch('./char_mappings.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for char_mappings.json`);
                const mappings = await response.json();
                charToIndex = mappings.char_to_index; indexToChar = mappings.index_to_char;
                modelSequenceLength = mappings.sequence_length; modelVocabSize = mappings.vocab_size;
                console.log("Character mappings loaded successfully.");
                if (!charToIndex || !indexToChar || !modelSequenceLength || !modelVocabSize) throw new Error("Character mapping data incomplete.");
            } catch (error) { console.error("Could not load char_mappings.json:", error); modelStatusText.textContent = "Model: CharMap Error"; tfModelLoaded = false; }
        }
        async function loadTFModel() { /* ... (implementation unchanged) ... */ 
            if (Object.keys(charToIndex).length === 0) { modelStatusText.textContent = "Model: Not Loaded (No CharMap)"; return; }
            modelStatusText.textContent = "Model: Loading...";
            try {
                tfModel = await tf.loadLayersModel('./tfjs_model_output_directory/model.json');
                tfModelLoaded = true; modelStatusText.textContent = "Model: Loaded"; console.log("TF.js model loaded.");
                if (tfModel && modelSequenceLength > 0 && modelVocabSize > 0) {
                    console.log("Warming up model...");
                    const dummyInput = tf.tensor2d([new Array(modelSequenceLength).fill(0)], [1, modelSequenceLength], 'int32');
                    tfModel.predict(dummyInput).dispose(); dummyInput.dispose(); console.log("Model warmed up.");
                }
            } catch (error) { console.error("Error loading TF.js model:", error); modelStatusText.textContent = "Model: Error loading"; tfModelLoaded = false; }
        }
        async function getTFModelSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!tfModelLoaded || !tfModel || !prefix || prefix.length === 0 || Object.keys(charToIndex).length === 0) return [];
            let currentGeneratedSequence = prefix.toLowerCase();
            const modelSuggestionsOutput = new Set();
            try {
                for (let i = 0; i < 7 && modelSuggestionsOutput.size < MAX_SUGGESTIONS ; i++) {
                    let inputChars = currentGeneratedSequence.slice(-modelSequenceLength).split('');
                    let inputIds = inputChars.map(char => charToIndex[char] || 0);
                    while (inputIds.length < modelSequenceLength) inputIds.unshift(0);
                    const inputTensor = tf.tensor2d([inputIds], [1, modelSequenceLength], 'int32');
                    let predictionTensor;
                    try {
                        predictionTensor = tfModel.predict(inputTensor);
                        const probabilities = await predictionTensor.data();
                        let predictedIndex = 0, maxProb = -1;
                        for (let j = 0; j < probabilities.length; j++) if (probabilities[j] > maxProb) { maxProb = probabilities[j]; predictedIndex = j; }
                        const predictedChar = indexToChar[predictedIndex];
                        if (!predictedChar || predictedChar === ' ') {
                            const potentialWord = currentGeneratedSequence.toUpperCase();
                            if (potentialWord.length > prefix.length && (BASE_WORD_LIST.includes(potentialWord) || PERSONALIZED_WORD_LIST[potentialWord])) modelSuggestionsOutput.add(potentialWord);
                            break;
                        }
                        currentGeneratedSequence += predictedChar;
                        const fullPotentialWord = currentGeneratedSequence.toUpperCase();
                        if (fullPotentialWord.length > prefix.length && (BASE_WORD_LIST.includes(fullPotentialWord) || PERSONALIZED_WORD_LIST[fullPotentialWord])) modelSuggestionsOutput.add(fullPotentialWord);
                        if (i === 0 && currentGeneratedSequence.length === prefix.length + 1) {
                            const shortCompletion = currentGeneratedSequence.toUpperCase();
                            if (BASE_WORD_LIST.includes(shortCompletion) || PERSONALIZED_WORD_LIST[shortCompletion]) modelSuggestionsOutput.add(shortCompletion);
                        }
                    } finally { inputTensor.dispose(); if (predictionTensor) predictionTensor.dispose(); }
                }
                return Array.from(modelSuggestionsOutput).map(text => ({ text, source: 'model' }));
            } catch (error) { console.error("Error during TF model prediction:", error); return []; }
        }
        async function loadWordLists() { /* ... (implementation unchanged) ... */ 
            try {
                const storedPersonalizedWords = localStorage.getItem('personalizedWordList');
                PERSONALIZED_WORD_LIST = storedPersonalizedWords ? JSON.parse(storedPersonalizedWords) : {};
            } catch (e) { PERSONALIZED_WORD_LIST = {}; }
            try {
                const response = await fetch('./common_words.txt');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();
                BASE_WORD_LIST = text.split(/\r?\n/).map(word => word.trim().toUpperCase()).filter(word => word.length > 0);
                if (BASE_WORD_LIST.length === 0) BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS];
            } catch (error) { BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS]; }
        }
        function savePersonalizedWords() { /* ... (implementation unchanged) ... */ 
            try { localStorage.setItem('personalizedWordList', JSON.stringify(PERSONALIZED_WORD_LIST)); } 
            catch (e) { console.error("Error saving personalized words:", e); }
        }
        function learnWord(word) { /* ... (implementation unchanged) ... */ 
            if (!word || typeof word !== 'string' || word.length === 0) return;
            const upperWord = word.trim().toUpperCase();
            if (upperWord.length < 2 && !["A", "I"].includes(upperWord)) return;
            PERSONALIZED_WORD_LIST[upperWord] = (PERSONALIZED_WORD_LIST[upperWord] || 0) + 1;
            savePersonalizedWords();
        }

        // --- Audio & EAR Calculation ---
        function initAudio() { /* ... (implementation unchanged) ... */ 
             if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        function playSound(type = "key_action") { /* ... (implementation unchanged) ... */ 
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                oscillator.type = 'square';
                let freq = 440; 
                if (type === "calibration_blink") freq = 660;
                else if (type === "calibration_done") freq = 880;
                else if (type === "row_select") freq = 330;
                else if (type === "suggestion_select") freq = 550;
                else if (type === "special_key_select") freq = 380; 
                else if (type === "special_char_select") freq = 480; 
                else if (type === "email_next") freq = 400;
                else if (type === "email_send") freq = 700;
                else if (type === "mouse_click") freq = 220; 
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.15);
            } catch (e) { console.error("Error playing sound:", type, e); }
        }
        function calculateDistance(p1, p2) { /* ... (implementation unchanged) ... */ 
            if (!p1 || !p2 || p1.x === undefined || p2.x === undefined) return 0.0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        function calculateEAR(eyeLandmarks) { /* ... (implementation unchanged) ... */ 
            if (!eyeLandmarks || eyeLandmarks.length !== 6) return 0.6; 
            for(let lm of eyeLandmarks) if(!lm || lm.x === undefined || lm.y === undefined) return 0.6;
            const v1 = calculateDistance(eyeLandmarks[1], eyeLandmarks[5]);
            const v2 = calculateDistance(eyeLandmarks[2], eyeLandmarks[4]);
            const h1 = calculateDistance(eyeLandmarks[0], eyeLandmarks[3]);
            return h1 <= 1e-6 ? 0.6 : (v1 + v2) / (2.0 * h1);
        }

        // --- Keyboard Layout & Highlighting ---
        function addKeyClickListener(keyElement, keyChar) {
            keyElement.addEventListener('click', () => {
                if (inputMethod === "click" && isCameraActive && !isCalibrating) { 
                    performKeyAction(keyChar, true); 
                }
            });
        }

        function generateKeyboardLayout(customLastRowChars = null) { 
            keyboardRows = []; 
            keyboardArea.innerHTML = ''; 
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
            let letterIdx = 0;

            for (let r = 0; r < NUM_ALPHABET_ROWS; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row'; rowDiv.id = `kb-row-${r}`;
                let currentLayoutRow = [];
                for (let i = 0; i < KEYS_PER_ALPHABET_ROW; i++) {
                    if (letterIdx < 24) { 
                        const char = letters[letterIdx++];
                        const keyDiv = document.createElement('div'); keyDiv.className = 'key'; keyDiv.id = `key-${r}-${i}`; keyDiv.textContent = char;
                        addKeyClickListener(keyDiv, char);
                        rowDiv.appendChild(keyDiv); currentLayoutRow.push({ char: char, element: keyDiv, row: r, col: i });
                    }
                }
                keyboardRows.push(currentLayoutRow); keyboardArea.appendChild(rowDiv);
            }

            const row4Div = document.createElement('div'); row4Div.className = 'keyboard-row'; row4Div.id = `kb-row-${NUM_ALPHABET_ROWS}`;
            let row4Layout = [];
            const row4KeyDefinitions = [
                { char: letters[24], display: letters[24], classList: 'key' }, 
                { char: letters[25], display: letters[25], classList: 'key' }, 
                { char: NUM_KEY_CHAR, display: NUM_KEY_CHAR, classList: 'key special-key' },
                { char: PUNC_KEY_CHAR, display: PUNC_KEY_CHAR, classList: 'key special-key' },
                { char: SPACE_KEY_CHAR, display: SPACE_KEY_DISPLAY_TEXT, classList: 'key' }, 
                { char: BACKSPACE_KEY_CHAR, display: BACKSPACE_KEY_CHAR, classList: 'key special-key backspace-key' }
            ];
            row4KeyDefinitions.forEach((keyDef, i) => {
                const keyDiv = document.createElement('div'); keyDiv.className = keyDef.classList; keyDiv.id = `key-${NUM_ALPHABET_ROWS}-${i}`; keyDiv.textContent = keyDef.display;
                addKeyClickListener(keyDiv, keyDef.char);
                row4Div.appendChild(keyDiv); row4Layout.push({ char: keyDef.char, element: keyDiv, row: NUM_ALPHABET_ROWS, col: i });
            });
            keyboardRows.push(row4Layout); keyboardArea.appendChild(row4Div);

            const row5Div = document.createElement('div'); row5Div.className = 'keyboard-row'; row5Div.id = `kb-row-${NUM_ALPHABET_ROWS + 1}`;
            let row5Layout = [];
            const finalRowCharsToUse = customLastRowChars || DEFAULT_SPECIAL_KEYS_FINAL_ROW_CHARS;
            finalRowCharsToUse.forEach((char, i) => {
                const keyDiv = document.createElement('div'); 
                keyDiv.className = 'key special-key final-row-key'; 
                keyDiv.id = `key-${NUM_ALPHABET_ROWS + 1}-${i}`; 
                keyDiv.textContent = char;
                addKeyClickListener(keyDiv, char);
                row5Div.appendChild(keyDiv); 
                row5Layout.push({ char: char, element: keyDiv, row: NUM_ALPHABET_ROWS + 1, col: i });
            });
            keyboardRows.push(row5Layout); keyboardArea.appendChild(row5Div);
            updateKeyAppearanceForInputMode();
        }
        function displaySpecialKeyboard(layoutConfig) { 
            keyboardArea.innerHTML = ''; 
            specialKeyboardRowElements = []; 
            activeSpecialKeyboardType = layoutConfig.type;

            const rowDiv = document.createElement('div');
            rowDiv.className = 'keyboard-row';
            rowDiv.id = `kb-special-row-${layoutConfig.type}`;

            layoutConfig.chars.forEach((char, i) => {
                const keyDiv = document.createElement('div');
                keyDiv.className = `key ${layoutConfig.type}-key`; 
                keyDiv.id = `key-special-${layoutConfig.type}-${i}`;
                keyDiv.textContent = char;
                addKeyClickListener(keyDiv, char);
                rowDiv.appendChild(keyDiv);
                specialKeyboardRowElements.push({ char: char, element: keyDiv, row: 0, col: i });
            });

            const cancelKeyDiv = document.createElement('div');
            cancelKeyDiv.className = 'key special-key'; 
            cancelKeyDiv.id = `key-special-${layoutConfig.type}-cancel`;
            cancelKeyDiv.textContent = CANCEL_KEY_CHAR;
            addKeyClickListener(cancelKeyDiv, CANCEL_KEY_CHAR);
            rowDiv.appendChild(cancelKeyDiv);
            specialKeyboardRowElements.push({ char: CANCEL_KEY_CHAR, element: cancelKeyDiv, row: 0, col: layoutConfig.chars.length });

            keyboardArea.appendChild(rowDiv);
            if (inputMethod === "blink") { 
                lastTraversalTime = performance.now(); 
                currentKeyScanIndexInRow = 0; 
            }
            updateKeyAppearanceForInputMode();
            updateKeyboardHighlight(); 
        }
        function displayEmailConfirmScreen() { 
            keyboardArea.innerHTML = ''; 
            specialKeyboardRowElements = []; 
            
            const rowDiv = document.createElement('div');
            rowDiv.className = 'keyboard-row'; 
            rowDiv.id = 'kb-email-confirm-row';

            const sendKeyDiv = document.createElement('div');
            sendKeyDiv.className = 'key special-key email-action-key'; 
            sendKeyDiv.id = 'key-email-send';
            sendKeyDiv.textContent = EMAIL_SEND_KEY;
            addKeyClickListener(sendKeyDiv, EMAIL_SEND_KEY);
            rowDiv.appendChild(sendKeyDiv);
            keyboardRows = [[ 
                { char: EMAIL_SEND_KEY, element: sendKeyDiv, row: 0, col: 0 }
            ]];


            const cancelKeyDiv = document.createElement('div');
            cancelKeyDiv.className = 'key special-key email-action-key';
            cancelKeyDiv.id = 'key-email-cancel-setup';
            cancelKeyDiv.textContent = EMAIL_CANCEL_SETUP_KEY;
            addKeyClickListener(cancelKeyDiv, EMAIL_CANCEL_SETUP_KEY);
            rowDiv.appendChild(cancelKeyDiv);
            keyboardRows[0].push({ char: EMAIL_CANCEL_SETUP_KEY, element: cancelKeyDiv, row: 0, col: 1 });


            keyboardArea.appendChild(rowDiv);
            
            console.log("displayEmailConfirmScreen: originalTypedTextBeforeEmail is:", originalTypedTextBeforeEmail); 
            typedTextArea.innerHTML = `To: ${receiverEmailUsername + EMAIL_DOMAIN_SUFFIX}<br>From: ${SENDER_EMAIL_ADDRESS}<br>Subject: Message via Eye Keyboard<br><br>Body:<br>${originalTypedTextBeforeEmail.replace(/\n/g, '<br>')}`;

            if (inputMethod === "blink") { 
                currentScanMode = SCANNING_MODE_EMAIL_SETUP; 
                currentRowScanIndex = 0; 
                currentKeyScanIndexInRow = 0;
                lastTraversalTime = performance.now();
            }
            updateKeyAppearanceForInputMode();
            updateKeyboardHighlight();
        }

        function updateKeyAppearanceForInputMode() {
            const allKeys = document.querySelectorAll('.key');
            const allSuggestions = document.querySelectorAll('.suggestion');
            if (inputMethod === "click") {
                allKeys.forEach(key => { key.style.cursor = 'pointer'; key.classList.add('clickable');});
                allSuggestions.forEach(sugg => { sugg.style.cursor = 'pointer'; sugg.classList.add('clickable');});
                 if (isCameraActive && !isCalibrating) { 
                    switchInputModeButton.disabled = false;
                }
            } else { // blink mode
                allKeys.forEach(key => { key.style.cursor = 'default'; key.classList.remove('clickable');});
                allSuggestions.forEach(sugg => { sugg.style.cursor = 'default'; sugg.classList.remove('clickable');});
                if (isCameraActive && !isCalibrating) {
                    switchInputModeButton.disabled = false;
                }
            }
        }


        function updateKeyboardHighlight() { 
            document.querySelectorAll('.key.highlighted, .key.selection-pending, .key.cancel-option-pending, .keyboard-row.row-highlighted, .keyboard-row.selection-pending')
                .forEach(el => el.classList.remove('highlighted', 'selection-pending', 'cancel-option-pending', 'row-highlighted'));
            suggestionsArea.querySelectorAll('.suggestion.highlighted, .suggestion.selection-pending')
                .forEach(sugg => sugg.classList.remove('highlighted', 'selection-pending'));

            if (inputMethod === "click" || isCalibrating || !initialDelayPassed || isPausedAfterSelection) {
                return; 
            }

            let elementToMark = null;
            let suggestionSource = null; 
            let isCancelForMainKeyboard = false; 

            if (currentScanMode === SCANNING_MODE_ROW) {
                if (keyboardRows[currentRowScanIndex]) { 
                    const rowDiv = document.getElementById(`kb-row-${currentRowScanIndex}`);
                    if (rowDiv) rowDiv.classList.add(isTraversalPausedForSelectionConsideration ? 'selection-pending' : 'row-highlighted');
                }
            } else if (currentScanMode === SCANNING_MODE_KEY) { 
                if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                    elementToMark = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].element;
                    if (isOfferingKeyScanCancel && keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].char === CANCEL_KEY_CHAR) {
                        isCancelForMainKeyboard = true; 
                    } else if (isOfferingGenericCancelForEmailRow && keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].char === EMAIL_CANCEL_SETUP_KEY) {
                        // This is when "Cancel Mail" button temporarily shows "CNCL"
                        elementToMark.classList.add('cancel-option-pending'); // Or a different style if needed
                    }
                }
            } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                const suggestions = suggestionsArea.querySelectorAll('.suggestion');
                if (activeSuggestionListForScanning?.[currentSuggestionIndex]) {
                    elementToMark = suggestions[currentSuggestionIndex];
                    suggestionSource = activeSuggestionListForScanning[currentSuggestionIndex].source;
                }
            } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) { 
                if (specialKeyboardRowElements[currentKeyScanIndexInRow]) {
                    elementToMark = specialKeyboardRowElements[currentKeyScanIndexInRow].element;
                }
            } else if (currentScanMode === SCANNING_MODE_EMAIL_SETUP) { 
                 if (keyboardRows[0] && keyboardRows[0][currentKeyScanIndexInRow]) { 
                    elementToMark = keyboardRows[0][currentKeyScanIndexInRow].element;
                }
            }


            if (elementToMark) {
                if (isCancelForMainKeyboard) { 
                    elementToMark.classList.add('cancel-option-pending');
                } else if (isTraversalPausedForSelectionConsideration) {
                    elementToMark.classList.add('selection-pending');
                } else if (!elementToMark.classList.contains('cancel-option-pending')) { // Don't override if already set by generic cancel
                    elementToMark.classList.add('highlighted');
                }
                if (suggestionSource === 'personalized') elementToMark.classList.add('personalized');
                else if (suggestionSource === 'model') elementToMark.classList.add('model-prediction');
            }
        }

        // --- Suggestions Logic ---
        function getPersonalizedSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            return Object.entries(PERSONALIZED_WORD_LIST)
                .filter(([word]) => word.toLowerCase().startsWith(prefixLower))
                .map(([text, frequency]) => ({ text, frequency, source: 'personalized' })) 
                .sort((a, b) => b.frequency - a.frequency);
        }
        async function getCombinedSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            let combined = [];
            const addedTexts = new Set(); 

            const personalized = getPersonalizedSuggestions(prefixLower);
            personalized.forEach(sugg => {
                if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                    combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                }
            });

            if (combined.length < MAX_SUGGESTIONS && tfModelLoaded) {
                const modelSuggestions = await getTFModelSuggestions(prefixLower); 
                modelSuggestions.forEach(sugg => {
                    if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                        combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                    }
                });
            }
            
            if (combined.length < MAX_SUGGESTIONS) {
                for (const word of BASE_WORD_LIST) {
                    if (combined.length >= MAX_SUGGESTIONS) break;
                    if (word.toLowerCase().startsWith(prefixLower) && !addedTexts.has(word.toLowerCase())) {
                        combined.push({ text: word, source: 'base' }); addedTexts.add(word.toLowerCase());
                    }
                }
            }
            return combined.slice(0, MAX_SUGGESTIONS); 
        }
        function displaySuggestions() { 
            suggestionsArea.innerHTML = '';
            if (isSettingUpEmail && emailSetupPhase === 'confirm_send') { 
                updateKeyboardHighlight();
                return;
            }
            const listToDisplay = (inputMethod === "blink" && currentScanMode === SCANNING_MODE_SUGGESTION) ? activeSuggestionListForScanning : currentSuggestionObjects;
            
            if (!listToDisplay || listToDisplay.length === 0) {
                suggestionsArea.innerHTML = ''; updateKeyboardHighlight(); return;
            }
            listToDisplay.forEach((suggObj, index) => {
                const suggDiv = document.createElement('div'); suggDiv.className = 'suggestion';
                suggDiv.textContent = suggObj.text; 
                if (suggObj.source === 'personalized') suggDiv.classList.add('personalized');
                else if (suggObj.source === 'model') suggDiv.classList.add('model-prediction');
                
                suggDiv.addEventListener('click', () => { 
                    if (inputMethod === "click" && isCameraActive && !isCalibrating) {
                        performKeyAction(suggObj.text, true, true); 
                    }
                });

                suggestionsArea.appendChild(suggDiv);
            });
            updateKeyAppearanceForInputMode(); 
            updateKeyboardHighlight(); 
        }

        // --- Core Action & State Management ---
        function resetToRowScan() { 
            currentScanMode = SCANNING_MODE_ROW;
            currentRowScanIndex = 0;
            selectedRowIndex = -1;
            originalSelectedRowForKeyScan = -1;
            currentKeyScanIndexInRow = 0; 
            activeSuggestionListForScanning = [];
            currentSuggestionIndex = 0;
            lastTraversalTime = performance.now();
            isTraversalPausedForSelectionConsideration = false;
            isOfferingKeyScanCancel = false;
            isOfferingGenericCancelForEmailRow = false; // Reset this flag
            eyeClosureFramesCount = 0;
            statusText.textContent = "Status: Row Scanning";
            updateKeyboardHighlight(); 
        }

        function resetAndDisplayMainKeyboard(fromEmailProcess = false, clearMainTypedTextAfterSend = false) { 
            const wasSettingUpEmail = isSettingUpEmail; 

            isSettingUpEmail = false;
            emailSetupPhase = "";
            emailSetupInstructions.textContent = "";

            if (fromEmailProcess) { 
                 typedTextArea.textContent = originalTypedTextBeforeEmail;
                 typedText = originalTypedTextBeforeEmail; 
            } else if (clearMainTypedTextAfterSend) { 
                typedText = "";
                typedTextArea.textContent = "";
            }
            
            originalTypedTextBeforeEmail = ""; 
            receiverEmailUsername = "";

            activeSpecialKeyboardType = null;
            specialKeyboardRowElements = [];
            
            generateKeyboardLayout(); 
            
            if (inputMethod === "blink") { 
                resetToRowScan();      
            } else { 
                const prefix = typedText.match(/([^\s]+)$/)?.[0] || "";
                getCombinedSuggestions(prefix).then(suggestions => {
                    currentSuggestionObjects = suggestions; displaySuggestions();
                }).catch(err => { currentSuggestionObjects = []; displaySuggestions();});
                updateKeyboardHighlight(); 
            }
            updateKeyAppearanceForInputMode();
        }

        function handleCalibration(avgEar) { /* ... (implementation unchanged) ... */ 
            if (!isCalibrating) return false; 

            calibrationInstructions.style.display = 'block';
            loadingMessage.textContent = `Calibrating: ${calibrationBlinksNeeded} blink(s) remaining.`;
            eyeStatusText.textContent = `EAR: ${avgEar.toFixed(2)} (Calibrating)`;

            if (calibrationState === "idle") {
                if (avgEar < INITIAL_EAR_FOR_CALIBRATION_DETECTION) {
                    calibrationState = "detecting_low";
                    calibrationFramesLowCount = 1;
                    currentCalibrationBlinkMinEar = avgEar; 
                }
            } else if (calibrationState === "detecting_low") {
                if (avgEar < INITIAL_EAR_FOR_CALIBRATION_DETECTION) {
                    calibrationFramesLowCount++;
                    if (avgEar < currentCalibrationBlinkMinEar) {
                        currentCalibrationBlinkMinEar = avgEar;
                    }
                } else { 
                    if (calibrationFramesLowCount >= CALIBRATION_BLINK_MIN_FRAMES_LOW) {
                        calibrationState = "detecting_high";
                        calibrationFramesHighCount = 1;
                    } else { 
                        calibrationState = "idle";
                        calibrationFramesLowCount = 0;
                        currentCalibrationBlinkMinEar = 1.0;
                    }
                }
            } else if (calibrationState === "detecting_high") {
                if (avgEar > INITIAL_EAR_FOR_CALIBRATION_DETECTION) { 
                    calibrationFramesHighCount++;
                    if (calibrationFramesHighCount >= CALIBRATION_BLINK_MIN_FRAMES_HIGH) {
                        
                        calibrationEarValues.push(currentCalibrationBlinkMinEar);
                        calibrationBlinksNeeded--;
                        playSound("calibration_blink");
                        loadingMessage.textContent = `Blink ${3 - calibrationBlinksNeeded} registered! Min EAR: ${currentCalibrationBlinkMinEar.toFixed(2)}. ${calibrationBlinksNeeded} more.`;
                        console.log(`Calibration blink ${3-calibrationBlinksNeeded} detected. Min EAR: ${currentCalibrationBlinkMinEar}`);

                        calibrationState = "idle";
                        calibrationFramesLowCount = 0;
                        calibrationFramesHighCount = 0;
                        currentCalibrationBlinkMinEar = 1.0;

                        if (calibrationBlinksNeeded === 0) {
                            if (calibrationEarValues.length > 0) {
                                const sumEar = calibrationEarValues.reduce((sum, val) => sum + val, 0);
                                const avgCalibratedEar = sumEar / calibrationEarValues.length;
                                minEarThreshold = avgCalibratedEar + (0.30 - avgCalibratedEar) * 0.5; 
                                if (minEarThreshold > 0.35) minEarThreshold = 0.35; 
                                if (minEarThreshold < 0.15) minEarThreshold = 0.15; 

                                playSound("calibration_done");
                                loadingMessage.textContent = `Calibration complete! New EAR Threshold: ${minEarThreshold.toFixed(2)}`;
                                console.log(`Calibration complete. Values: ${calibrationEarValues.join(', ')}. Average Min: ${avgCalibratedEar.toFixed(2)}. New Threshold: ${minEarThreshold.toFixed(2)}`);
                            } else {
                                minEarThreshold = 0.25; 
                                loadingMessage.textContent = "Calibration failed to get values, using default threshold.";
                                console.warn("Calibration completed with no EAR values, using default.");
                            }
                            isCalibrating = false;
                            calibrationInstructions.style.display = 'none';
                            startTime = performance.now();
                            initialDelayPassed = false;
                            statusText.textContent = "Status: Initializing keyboard...";
                            resetAndDisplayMainKeyboard(); 
                            switchInputModeButton.disabled = false; 
                            return true; 
                        }
                    }
                } else { 
                    calibrationState = "detecting_low"; 
                }
            }
            return true; 
        }

        function startEmailSetup() {
            isSettingUpEmail = true;
            emailSetupPhase = "enter_receiver"; 
            console.log("startEmailSetup: typedText before capture:", typedText);
            originalTypedTextBeforeEmail = typedText; 
            console.log("startEmailSetup: originalTypedTextBeforeEmail captured:", originalTypedTextBeforeEmail);
            typedText = ""; 
            typedTextArea.textContent = ""; 
            receiverEmailUsername = "";
            statusText.textContent = "Status: Email Setup";
            emailSetupInstructions.textContent = `Enter Receiver's Gmail Username (before ${EMAIL_DOMAIN_SUFFIX}).`;
            generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS); // Use specific bottom row for email
            
            if (inputMethod === "blink") { 
                currentScanMode = SCANNING_MODE_ROW; 
                currentRowScanIndex = 0; 
                currentKeyScanIndexInRow = 0;
                selectedRowIndex = -1;
                isOfferingKeyScanCancel = false; 
                isOfferingGenericCancelForEmailRow = false;
            }
            updateKeyboardHighlight();
            updateKeyAppearanceForInputMode();
        }

       function performKeyAction(char, isFromMouseClick = false, isSuggestion = false) {
            if (isFromMouseClick) playSound("mouse_click");
            // Blink mode sounds are handled by their respective selection logic points

            let wordToLearn = null;
            let postActionKeyboardResetNeeded = true; 
            let specificResetType = "main"; 

            // Priority 1: Num/Punc keys to display their keyboards (unless in final email confirm)
            if (char === NUM_KEY_CHAR && !(emailSetupPhase === "confirm_send")) {
                if(!isFromMouseClick && inputMethod === "blink") playSound("special_key_select");
                displaySpecialKeyboard(NUMBERS_LAYOUT_CONFIG);
                currentScanMode = SCANNING_MODE_SPECIAL_ROW; 
                statusText.textContent = "Status: Number Input";
                return; 
            } else if (char === PUNC_KEY_CHAR && !(emailSetupPhase === "confirm_send")) {
                if(!isFromMouseClick && inputMethod === "blink") playSound("special_key_select");
                displaySpecialKeyboard(PUNCTUATION_LAYOUT_CONFIG);
                currentScanMode = SCANNING_MODE_SPECIAL_ROW;
                statusText.textContent = "Status: Punctuation Input";
                return; 
            }
            // Priority 2: Final Email Confirmation Screen Actions
            else if (emailSetupPhase === "confirm_send") { 
                if (char === EMAIL_SEND_KEY) {
                    if(!isFromMouseClick && inputMethod === "blink") playSound("email_send");
                    const fullReceiver = receiverEmailUsername + EMAIL_DOMAIN_SUFFIX;
                    const mailtoLink = `mailto:${fullReceiver}?subject=${encodeURIComponent("Message via Eye Keyboard")}&body=${encodeURIComponent(originalTypedTextBeforeEmail + "\n\n(Sender: " + SENDER_EMAIL_ADDRESS + ")")}`;
                    window.open(mailtoLink, '_blank');
                    statusText.textContent = "Status: Email client opened.";
                    resetAndDisplayMainKeyboard(false, true); 
                } else if (char === EMAIL_CANCEL_SETUP_KEY) {
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    statusText.textContent = "Status: Email cancelled.";
                    resetAndDisplayMainKeyboard(true); 
                }
                return; 
            }
            // Priority 3: Suggestion Selection
            else if (isSuggestion) {
                 if(!isFromMouseClick && inputMethod === "blink") playSound("suggestion_select");
                 if (char !== SUGGESTION_SKIP_TEXT) {
                    const ls = typedText.lastIndexOf(' '); 
                    const baseText = isSettingUpEmail ? typedText.substring(0, typedText.lastIndexOf(SPACE_KEY_CHAR) +1 || 0) : (ls === -1 ? "" : typedText.substring(0, ls + 1));
                    typedText = baseText + char + (isSettingUpEmail ? "" : " "); 
                    typedTextArea.textContent = typedText; 
                    if (!isSettingUpEmail) learnWord(char);
                } 
                statusText.textContent = `Suggestion: ${char}`;
                currentSuggestionObjects = []; 
                specificResetType = isSettingUpEmail ? "email_setup_continue" : "main";
            }
            // Priority 4: Actions from an active Num/Punc keyboard
            else if (activeSpecialKeyboardType) { 
                 if(!isFromMouseClick && inputMethod === "blink") playSound("special_char_select");
                 if (char === CANCEL_KEY_CHAR) {
                    // Do nothing with text, just reset keyboard
                } else {
                    typedText += char; 
                    typedTextArea.textContent = typedText;
                }
                specificResetType = isSettingUpEmail ? "special_keyboard_return_to_email" : "special_keyboard_return_to_main";
                activeSpecialKeyboardType = null; 
            } 
            // Priority 5: Actions during email address input (not Num/Punc, not suggestion, not final confirm)
            else if (isSettingUpEmail) { 
                if(!isFromMouseClick && char !== EMAIL_NEXT_FIELD_KEY && char !== EMAIL_CANCEL_SETUP_KEY && char !== CANCEL_KEY_CHAR) playSound("key_action");

                if (char === EMAIL_NEXT_FIELD_KEY) {
                    playSound("email_next"); 
                    receiverEmailUsername = typedText; 
                    typedText = ""; 
                    emailSetupPhase = "confirm_send";
                    emailSetupInstructions.textContent = "Confirm and send?";
                    displayEmailConfirmScreen(); 
                    return; 
                    
                } else if (char === EMAIL_CANCEL_SETUP_KEY) { // This is the "Cancel Mail" from the email kbd's bottom row
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    resetAndDisplayMainKeyboard(true); 
                    postActionKeyboardResetNeeded = false; 
                } else if (char === CANCEL_KEY_CHAR && isOfferingGenericCancelForEmailRow) { // Generic "CNCL" for row, selected from the temporarily relabeled "Cancel Mail" button
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    const cancelMailKeyElement = keyboardRows[keyboardRows.length - 1].find(k => k.char === EMAIL_CANCEL_SETUP_KEY)?.element;
                    if (cancelMailKeyElement && cancelMailKeyElement.originalText) {
                        cancelMailKeyElement.textContent = cancelMailKeyElement.originalText;
                        delete cancelMailKeyElement.originalText;
                    }
                    isOfferingGenericCancelForEmailRow = false;
                    currentScanMode = SCANNING_MODE_ROW;
                    currentRowScanIndex = 0; 
                    selectedRowIndex = -1;
                    currentKeyScanIndexInRow = 0;
                    generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS);
                    statusText.textContent = "Status: Email Setup"; 
                    updateKeyboardHighlight();
                    postActionKeyboardResetNeeded = false;

                } else if (char === BACKSPACE_KEY_CHAR) {
                    typedText = typedText.slice(0, -1);
                } else if (char === DELETE_KEY_CHAR) {
                    const lastSpace = typedText.trimEnd().lastIndexOf(' ');
                    typedText = (lastSpace !== -1) ? typedText.substring(0, lastSpace + 1) : "";
                } else if (![SUGGEST_KEY_CHAR, MAIL_KEY_CHAR, SEARCH_KEY_CHAR, CANCEL_KEY_CHAR].includes(char)) { 
                    typedText += char;
                }
                typedTextArea.textContent = typedText;
                if (char !== EMAIL_NEXT_FIELD_KEY && char !== EMAIL_CANCEL_SETUP_KEY && char !== CANCEL_KEY_CHAR) { 
                     specificResetType = "email_setup_continue"; 
                }
            } 
            // Priority 6: Normal main keyboard actions
            else { 
                if (char === MAIL_KEY_CHAR) {
                    if(!isFromMouseClick && inputMethod === "blink") playSound("special_key_select");
                    startEmailSetup();
                    postActionKeyboardResetNeeded = false; 
                } else if (char === SEARCH_KEY_CHAR) {
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    if (typedText) window.open(`https://www.google.com/search?q=${encodeURIComponent(typedText)}`, '_blank');
                    currentSuggestionObjects = []; 
                    specificResetType = "main";
                } else if (char === BACKSPACE_KEY_CHAR) { 
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    typedText = typedText.slice(0, -1); 
                } else if (char === SPACE_KEY_CHAR) { 
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    const w = typedText.trim().split(/\s+/); if (w.length > 0 && w[w.length-1]) wordToLearn = w[w.length-1]; typedText += " "; 
                } else if (char === DELETE_KEY_CHAR) { 
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    const ls = typedText.trimEnd().lastIndexOf(' '); typedText = (ls !== -1) ? typedText.substring(0, ls + 1) : "";
                } else if (char === SUGGEST_KEY_CHAR) {
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action"); 
                    activeSuggestionListForScanning = [...currentSuggestionObjects];
                    activeSuggestionListForScanning.push({text: SUGGESTION_SKIP_TEXT, source: 'system'});
                    if (inputMethod === "blink") { 
                        currentScanMode = SCANNING_MODE_SUGGESTION; currentSuggestionIndex = 0;
                    }
                    statusText.textContent = "Status: Suggestion Scanning"; 
                    postActionKeyboardResetNeeded = false; 
                } else if (char === CANCEL_KEY_CHAR) { 
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                     specificResetType = "main";
                } else { // Regular character
                    if(!isFromMouseClick && inputMethod === "blink") playSound("key_action");
                    typedText += char;
                }
                
                typedTextArea.textContent = typedText;
                if(wordToLearn && !isSettingUpEmail) learnWord(wordToLearn); 
                if (!isFromMouseClick && ![SUGGEST_KEY_CHAR, MAIL_KEY_CHAR, SEARCH_KEY_CHAR, NUM_KEY_CHAR, PUNC_KEY_CHAR].includes(char)) {
                     statusText.textContent = `Action: ${char}`; 
                }
            }

            // Update suggestions if applicable
            if (postActionKeyboardResetNeeded || isSuggestion || specificResetType === "special_keyboard_return_to_main" || specificResetType === "special_keyboard_return_to_email" ) {
                if (!isSettingUpEmail || (isSettingUpEmail && emailSetupPhase !== "confirm_send")) {
                    if (![MAIL_KEY_CHAR, SEARCH_KEY_CHAR, SUGGEST_KEY_CHAR, CANCEL_KEY_CHAR, EMAIL_NEXT_FIELD_KEY, EMAIL_SEND_KEY, EMAIL_CANCEL_SETUP_KEY, NUM_KEY_CHAR, PUNC_KEY_CHAR].includes(char) || char === SPACE_KEY_CHAR || char === BACKSPACE_KEY_CHAR || char === DELETE_KEY_CHAR || isSuggestion) {
                       const prefix = typedText.match(/([^\s]+)$/)?.[0] || "";
                       getCombinedSuggestions(prefix).then(suggestions => { currentSuggestionObjects = suggestions; displaySuggestions(); });
                    } else if (char === SEARCH_KEY_CHAR || char === MAIL_KEY_CHAR) { 
                       currentSuggestionObjects = []; displaySuggestions();
                    }
                }
            }

            if (postActionKeyboardResetNeeded) {
                if (inputMethod === "blink") { 
                    if (specificResetType === "main" || specificResetType === "special_keyboard_return_to_main") {
                        resetAndDisplayMainKeyboard(false); 
                    } else if (specificResetType === "email_setup_continue" || specificResetType === "special_keyboard_return_to_email") {
                        generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS);
                        resetToRowScan();
                    }
                } else { // Click mode
                    if (specificResetType === "main" || specificResetType === "special_keyboard_return_to_main") {
                        resetAndDisplayMainKeyboard(false);
                    } else if (specificResetType === "email_setup_continue" || specificResetType === "special_keyboard_return_to_email") {
                        generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS);
                        updateKeyAppearanceForInputMode(); 
                        updateKeyboardHighlight(); 
                    }
                }
            }
            if (inputMethod === "click") updateKeyAppearanceForInputMode();
        }


        function onResults(results) { 
            if (inputMethod === "click" || !isCameraActive) { 
                if (!isCalibrating) { 
                     canvasCtx.save();
                     canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                     canvasCtx.restore();
                }
                return;
            }

            const currentTime = performance.now();
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            let selectionTriggeredThisFrame = false;
            let avgEar = 0.6;

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                avgEar = (calculateEAR(LEFT_EYE_INDICES.map(i => landmarks[i])) + calculateEAR(RIGHT_EYE_INDICES.map(i => landmarks[i]))) / 2.0;

                if (isCalibrating) {
                    if (handleCalibration(avgEar)) { canvasCtx.restore(); return; }
                }

                eyeStatusText.textContent = `EAR: ${avgEar.toFixed(2)}${isTraversalPausedForSelectionConsideration ? ` (Paused - ${eyeClosureFramesCount})` : ""}`;

                if (avgEar < minEarThreshold) {
                     if (initialDelayPassed && !isPausedAfterSelection) { 
                        isTraversalPausedForSelectionConsideration = true; eyeClosureFramesCount++;
                    }
                } else { 
                    if (isTraversalPausedForSelectionConsideration) {
                        if (eyeClosureFramesCount >= SELECTION_BLINK_MIN_FRAMES) {
                            if (!isPausedAfterSelection && initialDelayPassed) {
                                selectionTriggeredThisFrame = true;
                            }
                        }
                        eyeClosureFramesCount = 0; isTraversalPausedForSelectionConsideration = false;
                    }
                }
            } else { 
                if (isCalibrating) {
                    loadingMessage.textContent = "Calibrating: No face detected.";
                }
                eyeStatusText.textContent = "EAR: N/A (No face detected)";
                eyeClosureFramesCount = 0;
                isTraversalPausedForSelectionConsideration = false;

                if (currentScanMode === SCANNING_MODE_KEY && isOfferingKeyScanCancel) {
                    isOfferingKeyScanCancel = false; 
                    resetAndDisplayMainKeyboard(isSettingUpEmail); 
                }
                else if (currentScanMode === SCANNING_MODE_EMAIL_SETUP) { 
                     resetAndDisplayMainKeyboard(true); 
                }
                else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) { 
                    if (isSettingUpEmail) {
                        generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS);
                        currentScanMode = SCANNING_MODE_ROW; 
                        currentRowScanIndex = 0; currentKeyScanIndexInRow = 0; selectedRowIndex = -1;
                        statusText.textContent = "Status: Email Setup (Reacquire Face)";
                        emailSetupInstructions.textContent = `Enter Receiver's Gmail Username (before ${EMAIL_DOMAIN_SUFFIX}).`;
                        updateKeyboardHighlight();
                    } else {
                        resetAndDisplayMainKeyboard(false);
                    }
                }
            }

            if (isPausedAfterSelection && (currentTime - lastSelectionTime) / 1000 >= POST_SELECTION_PAUSE) {
                isPausedAfterSelection = false; lastTraversalTime = currentTime;
            }

            if (!isCalibrating && !initialDelayPassed) {
                const elapsed = (currentTime - startTime) / 1000;
                statusText.textContent = `Status: Initializing... (${(INITIAL_DELAY - elapsed).toFixed(1)}s)`;
                if (elapsed >= INITIAL_DELAY) { initialDelayPassed = true; lastTraversalTime = currentTime; resetToRowScan(); } 
            } else if (!isCalibrating && !isPausedAfterSelection && inputMethod === "blink") { 
                if (selectionTriggeredThisFrame) {
                    lastSelectionTime = currentTime; isPausedAfterSelection = true;
                    isTraversalPausedForSelectionConsideration = false; eyeClosureFramesCount = 0;
                    
                    let charToProcess = null;
                    let isSuggestionSelection = false;

                    if (currentScanMode === SCANNING_MODE_EMAIL_SETUP) {
                        charToProcess = keyboardRows[0][currentKeyScanIndexInRow].char;
                    } else if (currentScanMode === SCANNING_MODE_ROW) {
                        if (keyboardRows[currentRowScanIndex]) {
                            selectedRowIndex = currentRowScanIndex; originalSelectedRowForKeyScan = currentRowScanIndex;
                            currentScanMode = SCANNING_MODE_KEY; currentKeyScanIndexInRow = 0;
                            isOfferingKeyScanCancel = false; 
                            isOfferingGenericCancelForEmailRow = false; // Reset this when a new row is selected
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; playSound("row_select");
                        }
                         updateKeyboardHighlight(); canvasCtx.restore(); return; 
                    } else if (currentScanMode === SCANNING_MODE_KEY) {
                        if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                            if(isOfferingGenericCancelForEmailRow) { // If the temporary "CNCL" (on Cancel Mail button) was selected
                                charToProcess = CANCEL_KEY_CHAR; // Process it as a generic cancel for the row
                            } else {
                                charToProcess = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].char;
                            }
                        } else { resetAndDisplayMainKeyboard(isSettingUpEmail); updateKeyboardHighlight(); canvasCtx.restore(); return; }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                         if (activeSuggestionListForScanning?.[currentSuggestionIndex]) {
                            charToProcess = activeSuggestionListForScanning[currentSuggestionIndex].text;
                            isSuggestionSelection = true;
                         } else { resetAndDisplayMainKeyboard(isSettingUpEmail); updateKeyboardHighlight(); canvasCtx.restore(); return; }
                    } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) {
                        if (specialKeyboardRowElements[currentKeyScanIndexInRow]) {
                            charToProcess = specialKeyboardRowElements[currentKeyScanIndexInRow].char;
                        } else { resetAndDisplayMainKeyboard(isSettingUpEmail); updateKeyboardHighlight(); canvasCtx.restore(); return; }
                    }

                    if (charToProcess !== null) {
                        performKeyAction(charToProcess, false, isSuggestionSelection);
                    }

                } else if (!isTraversalPausedForSelectionConsideration && (currentTime - lastTraversalTime) / 1000 >= TRAVERSAL_INTERVAL) { 
                    if (currentScanMode === SCANNING_MODE_EMAIL_SETUP) { 
                        currentKeyScanIndexInRow = (currentKeyScanIndexInRow + 1) % keyboardRows[0].length; 
                        statusText.textContent = "Status: Confirm Email";
                    } else if (currentScanMode === SCANNING_MODE_ROW) {
                        currentRowScanIndex = (currentRowScanIndex + 1) % keyboardRows.length;
                        statusText.textContent = isSettingUpEmail ? "Status: Email Setup" : "Status: Row Scanning";
                        isOfferingGenericCancelForEmailRow = false; // Reset when moving to a new row
                        const cancelMailKeyElement = document.getElementById('key-email-cancel-setup') || (keyboardRows[keyboardRows.length-1]?.find(k => k.char === EMAIL_CANCEL_SETUP_KEY)?.element);
                        if(cancelMailKeyElement && cancelMailKeyElement.originalText) {
                            cancelMailKeyElement.textContent = cancelMailKeyElement.originalText;
                            delete cancelMailKeyElement.originalText;
                        }

                    } else if (currentScanMode === SCANNING_MODE_KEY) {
                        if (isOfferingGenericCancelForEmailRow) { // Was offering CNCL (via Cancel Mail button), now loop back to char row
                            const cancelMailKeyElement = keyboardRows[keyboardRows.length - 1].find(k => k.char === EMAIL_CANCEL_SETUP_KEY)?.element;
                            if (cancelMailKeyElement && cancelMailKeyElement.originalText) {
                                cancelMailKeyElement.textContent = cancelMailKeyElement.originalText;
                                delete cancelMailKeyElement.originalText;
                            }
                            isOfferingGenericCancelForEmailRow = false;
                            selectedRowIndex = originalSelectedRowForKeyScan;
                            currentKeyScanIndexInRow = 0;
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;

                        } else if (isOfferingKeyScanCancel) { // Offering main CNCL key from bottom row
                            isOfferingKeyScanCancel = false; 
                            selectedRowIndex = originalSelectedRowForKeyScan;
                            currentKeyScanIndexInRow = 0;
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                        } else {
                            currentKeyScanIndexInRow++;
                            if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex] && currentKeyScanIndexInRow >= keyboardRows[selectedRowIndex].length) {
                                if (isSettingUpEmail) {
                                    isOfferingGenericCancelForEmailRow = true;
                                    originalSelectedRowForKeyScan = selectedRowIndex;
                                    const emailKeyboardLastRow = keyboardRows[keyboardRows.length - 1];
                                    const cancelMailKeyIndex = emailKeyboardLastRow.findIndex(k => k.char === EMAIL_CANCEL_SETUP_KEY);
                                    if (cancelMailKeyIndex !== -1) {
                                        const cancelMailKeyElement = emailKeyboardLastRow[cancelMailKeyIndex].element;
                                        cancelMailKeyElement.originalText = EMAIL_CANCEL_SETUP_KEY;
                                        cancelMailKeyElement.textContent = CANCEL_KEY_CHAR;
                                        selectedRowIndex = keyboardRows.length - 1;
                                        currentKeyScanIndexInRow = cancelMailKeyIndex;
                                        statusText.textContent = "Status: Cancel Row?";
                                    }
                                } else { // Normal main keyboard cancel offering
                                    isOfferingKeyScanCancel = true; originalSelectedRowForKeyScan = selectedRowIndex;
                                    selectedRowIndex = keyboardRows.length - 1; 
                                    const cancelKeyObj = keyboardRows[selectedRowIndex].find(key => key.char === CANCEL_KEY_CHAR);
                                    currentKeyScanIndexInRow = cancelKeyObj ? keyboardRows[selectedRowIndex].indexOf(cancelKeyObj) : 0;
                                    statusText.textContent = "Status: Cancel Option?";
                                }
                            } else if (selectedRowIndex == -1 || !keyboardRows[selectedRowIndex]) { 
                                resetAndDisplayMainKeyboard(isSettingUpEmail);
                            } else { 
                                statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; 
                            }
                        }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                        if (activeSuggestionListForScanning?.length > 0) currentSuggestionIndex = (currentSuggestionIndex + 1) % activeSuggestionListForScanning.length;
                        else { resetAndDisplayMainKeyboard(isSettingUpEmail); } 
                        statusText.textContent = "Status: Suggestion Scanning";
                    } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) {
                        currentKeyScanIndexInRow = (currentKeyScanIndexInRow + 1) % specialKeyboardRowElements.length;
                        statusText.textContent = `Status: ${activeSpecialKeyboardType === 'number' ? 'Number' : 'Punctuation'} Input`;
                    }
                    lastTraversalTime = currentTime;
                } else if (isTraversalPausedForSelectionConsideration && !statusText.textContent.includes("Evaluating")) {
                    statusText.textContent = "Status: Evaluating Blink...";
                } else if (!isCalibrating && !isTraversalPausedForSelectionConsideration && !isOfferingKeyScanCancel && !isOfferingGenericCancelForEmailRow &&
                           !statusText.textContent.startsWith("Status: Initializing") &&
                           !statusText.textContent.startsWith("Action:") &&
                           !statusText.textContent.startsWith("Suggestion:") &&
                           currentScanMode !== SCANNING_MODE_EMAIL_SETUP) { 
                    if (currentScanMode === SCANNING_MODE_ROW) statusText.textContent = isSettingUpEmail ? "Status: Email Setup" : "Status: Row Scanning";
                    else if (currentScanMode === SCANNING_MODE_KEY && selectedRowIndex !== -1) statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                    else if (currentScanMode === SCANNING_MODE_SUGGESTION && activeSuggestionListForScanning?.length > 0) statusText.textContent = "Status: Suggestion Scanning";
                    else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) statusText.textContent = `Status: ${activeSpecialKeyboardType === 'number' ? 'Number' : 'Punctuation'} Input`;
                }
            }
            updateKeyboardHighlight();
            canvasCtx.restore();
        }

        // --- Application Initialization ---
        async function startApp() { /* ... (implementation unchanged) ... */ 
            stopAutoStartTimer();
            isAutoStartPaused = false; 
            isCameraActive = false; 

            currentSuggestionIndex = 0; 
            await loadWordLists();
            await loadCharMappings();
            await loadTFModel();
            initAudio();
            startButton.disabled = true; startButton.textContent = "Loading...";
            switchInputModeButton.disabled = true; 
            loadingMessage.textContent = "Initializing MediaPipe..."; loadingMessage.style.display = 'block';
            calibrationInstructions.style.display = 'none';
            emailSetupInstructions.textContent = "";


            try {
                faceMesh = new FaceMesh({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                faceMesh.onResults(onResults);
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                };
                if (typeof Camera === "undefined") throw new Error("Camera utility not loaded from MediaPipe.");
                camera = new Camera(videoElement, {
                    onFrame: async () => { 
                        if (inputMethod === "blink" && videoElement.readyState >= 2 && isCameraActive) { 
                            await faceMesh.send({image: videoElement}); 
                        } else if (videoElement.readyState >=2) {
                            if (inputMethod === "click" && isCameraActive) {
                                canvasCtx.save();
                                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                                canvasCtx.restore();
                            }
                        }
                    },
                    width: FRAME_WIDTH, height: FRAME_HEIGHT
                });
                await camera.start();
                isCameraActive = true; 
                startButton.textContent = "Stop Camera"; 
                startButton.disabled = false;


                if (videoElement.videoWidth > 0 && (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight) ) {
                    canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
                }

                if (inputMethod === "blink") { 
                    isCalibrating = true;
                    calibrationBlinksNeeded = 3; calibrationEarValues = []; calibrationState = "idle";
                    calibrationFramesLowCount = 0; calibrationFramesHighCount = 0; currentCalibrationBlinkMinEar = 1.0;
                    loadingMessage.textContent = "Camera started. Calibrating...";
                    calibrationInstructions.textContent = "Please look at the camera and blink SLOWLY three times when your eyes feel normal.";
                    calibrationInstructions.style.display = 'block';
                    statusText.textContent = "Status: Calibrating";
                    switchInputModeButton.disabled = true; 
                } else { 
                    isCalibrating = false;
                    loadingMessage.textContent = "Camera started for Click Mode.";
                    statusText.textContent = "Status: Click Input Mode";
                    initialDelayPassed = true; 
                    resetAndDisplayMainKeyboard();
                    switchInputModeButton.disabled = false;
                }


            } catch (err) {
                console.error("Error during startApp:", err);
                loadingMessage.textContent = `Error: ${err.message}. Check console & permissions.`;
                statusText.textContent = "Status: Error"; modelStatusText.textContent = "Model: Error";
                startButton.disabled = false; startButton.textContent = "Start Camera"; 
                switchInputModeButton.textContent = "Use Click Input";
                switchInputModeButton.disabled = true;
                isAutoStartPaused = false; 
                isCameraActive = false;
                calibrationInstructions.style.display = 'none';
            }
            updateKeyAppearanceForInputMode();
        }

        function stopCamera() {
            if (camera) {
                camera.stop(); 
            }
            isCameraActive = false;
            isCalibrating = false; 
            initialDelayPassed = false; 

            videoElement.pause();
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height); 

            startButton.textContent = "Start Camera";
            startButton.disabled = false;
            switchInputModeButton.disabled = true; 
            switchInputModeButton.textContent = (inputMethod === "blink") ? "Use Click Input" : "Use Blink Input"; 


            statusText.textContent = "Status: Camera Off";
            eyeStatusText.textContent = "EAR: N/A";
            loadingMessage.textContent = "Camera stopped.";
            calibrationInstructions.style.display = 'none';
            emailSetupInstructions.textContent = "";
            keyboardArea.innerHTML = ""; 
            suggestionsArea.innerHTML = ""; 
            typedTextArea.textContent = ""; 
            typedText = "";
            currentSuggestionObjects = [];
            activeSuggestionListForScanning = [];
        }


        // Event Listeners
        startButton.addEventListener('click', () => {
            if (isCameraActive) {
                stopCamera();
                stopAutoStartTimer(); 
                isAutoStartPaused = true; 
            } else {
                if (isAutoStartActive) { 
                    stopAutoStartTimer();
                    isAutoStartPaused = true;
                    startButton.textContent = "Start Camera (Paused)";
                    loadingMessage.textContent = "Auto-start paused. Click button to start manually.";
                } else { 
                    isAutoStartPaused = false; 
                    startApp(); 
                }
            }
        });
        
        switchInputModeButton.addEventListener('click', () => {
            if (!isCameraActive || isCalibrating) return; 

            inputMethod = (inputMethod === "blink") ? "click" : "blink"; 
            switchInputModeButton.textContent = (inputMethod === "blink") ? "Use Click Input" : "Use Blink Input"; 
            
            updateKeyAppearanceForInputMode();
            updateKeyboardHighlight(); 

            if (inputMethod === "blink") { 
                statusText.textContent = "Status: Blink Input Mode"; 
                eyeStatusText.style.display = 'block'; 
                if (isCameraActive && !isCalibrating) { 
                     resetAndDisplayMainKeyboard(isSettingUpEmail); 
                }
            } else { 
                statusText.textContent = "Status: Click Input Mode";
                eyeStatusText.style.display = 'none'; 
                if (isSettingUpEmail) {
                    if (emailSetupPhase === 'confirm_send') {
                        displayEmailConfirmScreen();
                    } else {
                         generateKeyboardLayout(EMAIL_SETUP_FINAL_ROW_CHARS);
                    }
                } else if (activeSpecialKeyboardType) {
                    displaySpecialKeyboard(activeSpecialKeyboardType === 'number' ? NUMBERS_LAYOUT_CONFIG : PUNCTUATION_LAYOUT_CONFIG);
                } else {
                    generateKeyboardLayout();
                }
                 updateKeyAppearanceForInputMode();
                 updateKeyboardHighlight(); 
            }
        });


        window.addEventListener('load', () => {
            switchInputModeButton.disabled = true; 
            startAutoStartTimer(); 
        });

    </script>
</body>
</html>
