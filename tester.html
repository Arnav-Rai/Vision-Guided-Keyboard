<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard - User-Triggered Suggestion Scan V6 (Updated Labels)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #282c34;
            color: #abb2bf;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .app-container {
            background-color: #353a40;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 450px; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls {
            margin-bottom: 20px;
            text-align: center;
        }

        #startButton {
            padding: 12px 20px; 
            font-size: 0.9em; 
            background-color: #61afef;
            color: #282c34;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 220px; 
            white-space: normal; 
            line-height: 1.3;
        }
        #startButton:hover {
            background-color: #529bcf;
        }
        #startButton:disabled {
            background-color: #4a5058;
            color: #7f848e;
            cursor: not-allowed;
        }

        #loadingMessage, .status-text {
            margin-top: 10px;
            font-size: 0.9em;
            color: #98c379;
            min-height: 1.2em; 
        }
        #eyeStatus {
            color: #e06c75;
        }
         #modelStatus {
            color: #c678dd;
            font-size: 0.8em;
        }
        #calibrationInstructions {
            margin-top: 15px;
            padding: 10px;
            background-color: #4a5058;
            border-radius: 6px;
            font-size: 0.95em;
            color: #e5c07b; 
            text-align: center;
            display: none; 
        }


        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            aspect-ratio: 16 / 9;
            border: 1px solid #4a5058;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            background-color: #21252b;
        }
        video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }
        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }

        #typedTextArea {
            width: 100%;
            max-width: 640px;
            min-height: 60px;
            background-color: #21252b;
            border: 1px solid #4a5058;
            padding: 12px;
            margin-bottom: 20px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 1.3em;
            color: #d19a66;
            border-radius: 8px;
            line-height: 1.5;
        }

        #keyboardArea {
            margin-bottom: 15px;
            display: grid;
            gap: 8px;
            width: 100%;
        }
        .keyboard-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        .key {
            width: 55px;
            height: 55px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1em;
            font-weight: bold;
            cursor: default;
            user-select: none;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease, border-color 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        .key.special-key {
            background-color: #5c6370;
            font-size: 0.75em; 
            padding: 0 3px; 
            line-height: 1.2; 
            text-align: center;
            word-break: keep-all; /* Try to prevent breaking words like "Suggest" */
        }

        .key.backspace-key {
             width: 55px;
        }
         .key.final-row-key { 
            width: 86.5px; 
            /* font-size might need adjustment if "Suggest" or "Search" are too long */
            /* Example: font-size: 0.7em; if needed */
         }
         .key.number-key, .key.punctuation-key { 
            font-size: 1.1em; 
         }


        .key.highlighted {
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .key.selection-pending {
            background-color: #FFC107;
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1);
        }
        .suggestion.selection-pending {
            background-color: #FFC107;
            color: #21252b;
            border: 2px solid #FFA000;
            transform: scale(1.1);
        }
         .keyboard-row.selection-pending .key { 
            background-color: #FFC107 !important;
            color: #21252b !important;
            border: 2px solid #FFA000 !important;
        }
        .key.cancel-option-pending { 
            background-color: #e06c75 !important;
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
            transform: scale(1.1);
        }


        .row-highlighted .key {
            background-color: #61afef;
            color: #282c34;
            border-color: #529bcf;
        }
        .row-highlighted .key.highlighted { 
            background-color: #98c379;
            color: #282c34;
            border-color: #88b369;
        }
        .row-highlighted .key.cancel-option-pending { 
             background-color: #e06c75 !important;
            color: #ffffff !important;
            border: 2px solid #d05c65 !important;
        }


        #suggestionsArea {
            margin-bottom: 20px;
            display: flex;
            gap: 8px;
            height: 40px;
            justify-content: center;
        }
        .suggestion {
            padding: 0 15px;
            background-color: #4a5058;
            color: #abb2bf;
            border: 1px solid #3b3f45;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: 500;
            cursor: default;
            user-select: none;
            min-width: 90px;
            height: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            transition: background-color 0.1s ease, transform 0.1s ease;
        }
        .suggestion.highlighted {
            background-color: #c678dd;
            color: #282c34;
            border-color: #b668cc;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
        .suggestion.personalized {
            border-left: 4px solid #61afef;
            font-style: italic;
        }
        .suggestion.model-prediction {
            border-left: 4px solid #98c379;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="controls">
            <button id="startButton">Start Camera</button>
            <p id="loadingMessage">Click 'Start Camera' or wait for auto-start.</p>
            <p id="calibrationInstructions">Please blink slowly three times.</p>
            <p class="status-text" id="statusText">Status: Idle</p>
            <p class="status-text" id="eyeStatus">EAR: N/A</p>
            <p class="status-text" id="modelStatus">Model: Not loaded</p>
        </div>

        <div class="video-container">
            <video id="input_video" autoplay muted playsinline></video>
            <canvas class="output_canvas" id="output_canvas"></canvas>
        </div>

        <div id="typedTextArea"></div>
        <div id="suggestionsArea"></div>
        <div id="keyboardArea"></div>
    </div>

    <script type="module">
        // DOM Elements
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const typedTextArea = document.getElementById('typedTextArea');
        const keyboardArea = document.getElementById('keyboardArea');
        const suggestionsArea = document.getElementById('suggestionsArea');
        const statusText = document.getElementById('statusText');
        const eyeStatusText = document.getElementById('eyeStatus');
        const modelStatusText = document.getElementById('modelStatus');
        const startButton = document.getElementById('startButton');
        const loadingMessage = document.getElementById('loadingMessage');
        const calibrationInstructions = document.getElementById('calibrationInstructions');

        // --- Configuration ---
        const FRAME_WIDTH = 640;
        const FRAME_HEIGHT = 360;

        let BASE_WORD_LIST = [];
        let PERSONALIZED_WORD_LIST = {};
        const DEFAULT_FALLBACK_WORDS = ["HELLO", "WORLD", "YES", "NO", "PLEASE", "THANK", "YOU", "GOOD", "MORNING", "AFTERNOON", "EVENING", "HELP"];
        const MAX_SUGGESTIONS = 3;
        const SUGGESTION_SKIP_TEXT = "[Skip]"; // Keeping brackets for this system message

        const SUGGEST_KEY_CHAR = "Suggest"; // Updated
        const SEARCH_KEY_CHAR = "Search";   // Updated
        const BACKSPACE_KEY_CHAR = "<-";
        const DELETE_KEY_CHAR = "DEL";      // Already no brackets
        const CANCEL_KEY_CHAR = "CNCL";     // Already no brackets
        const SPACE_KEY_CHAR = " ";
        const SPACE_KEY_DISPLAY_TEXT = "SPACE";
        const NUM_KEY_CHAR = "Num";         // Updated
        const PUNC_KEY_CHAR = "[,.]";       // Brackets retained as requested

        const NUMBERS_LAYOUT_CONFIG = { chars: "1234567890".split(''), type: 'number' };
        const PUNCTUATION_LAYOUT_CONFIG = { chars: ",.@?!'".split(''), type: 'punctuation' };


        const KEYS_PER_ALPHABET_ROW = 6;
        const NUM_ALPHABET_ROWS = 4; 
        const SPECIAL_KEYS_FINAL_ROW_CHARS = [SUGGEST_KEY_CHAR, SEARCH_KEY_CHAR, DELETE_KEY_CHAR, CANCEL_KEY_CHAR];


        const TRAVERSAL_INTERVAL = 0.8; 
        const POST_SELECTION_PAUSE = 0.6; 
        const INITIAL_DELAY = 1.0; 
        let minEarThreshold = 0.25; 
        const INITIAL_EAR_FOR_CALIBRATION_DETECTION = 0.20;
        const CALIBRATION_BLINK_MIN_FRAMES_LOW = 2;
        const CALIBRATION_BLINK_MIN_FRAMES_HIGH = 2;
        const SELECTION_BLINK_MIN_FRAMES = 2; 

        // State Variables
        let keyboardRows = []; 
        let currentScanMode;
        let currentRowScanIndex = 0;
        let currentKeyScanIndexInRow = 0; 
        let selectedRowIndex = -1; 
        let originalSelectedRowForKeyScan = -1;
        let lastTraversalTime = performance.now();
        let typedText = "";
        let isPausedAfterSelection = false;
        let lastSelectionTime = 0;
        let initialDelayPassed = false;
        let startTime = performance.now();
        let currentSuggestionObjects = [];
        let activeSuggestionListForScanning = [];
        let eyeClosureFramesCount = 0;
        let isTraversalPausedForSelectionConsideration = false;
        let isOfferingKeyScanCancel = false; 
        let currentSuggestionIndex = 0;

        let faceMesh;
        let camera;
        let audioCtx;

        let tfModel = null;
        let tfModelLoaded = false;
        let charToIndex = {};
        let indexToChar = {};
        let modelSequenceLength = 20;
        let modelVocabSize = 0;

        // Calibration State
        let isCalibrating = false;
        let calibrationBlinksNeeded = 3;
        let calibrationEarValues = [];
        let calibrationState = "idle";
        let calibrationFramesLowCount = 0;
        let calibrationFramesHighCount = 0;
        let currentCalibrationBlinkMinEar = 1.0;

        // Auto-start State
        let autoStartTimerId = null;
        let autoStartCountdown = 2; 
        const AUTO_START_INTERVAL = 1000; 
        let isAutoStartActive = false; 
        let isAutoStartPaused = false; 


        // Special Keyboard State
        let activeSpecialKeyboardType = null; 
        let specialKeyboardRowElements = []; 

        const SCANNING_MODE_ROW = 0;
        const SCANNING_MODE_KEY = 1; 
        const SCANNING_MODE_SUGGESTION = 2;
        const SCANNING_MODE_SPECIAL_ROW = 3; 

        const LEFT_EYE_INDICES = [362, 385, 387, 263, 373, 380];
        const RIGHT_EYE_INDICES = [33, 160, 158, 133, 153, 144];

        // --- Auto-start Camera Logic ---
        function startAutoStartTimer() {
            if (autoStartTimerId) clearInterval(autoStartTimerId); 
            isAutoStartActive = true;
            isAutoStartPaused = false;
            autoStartCountdown = 2; 
            startButton.textContent = `Starting in ${autoStartCountdown}s... (Click to Pause)`;
            startButton.disabled = false; 

            autoStartTimerId = setInterval(() => {
                autoStartCountdown--;
                if (autoStartCountdown > 0) {
                    startButton.textContent = `Starting in ${autoStartCountdown}s... (Click to Pause)`;
                } else {
                    clearInterval(autoStartTimerId);
                    autoStartTimerId = null;
                    isAutoStartActive = false;
                    startButton.textContent = "Starting..."; 
                    startButton.disabled = true;
                    startApp(); 
                }
            }, AUTO_START_INTERVAL);
        }

        function stopAutoStartTimer() {
            if (autoStartTimerId) {
                clearInterval(autoStartTimerId);
                autoStartTimerId = null;
            }
            isAutoStartActive = false;
        }

        // --- Model Loading & Word Lists ---
        async function loadCharMappings() { /* ... (implementation unchanged) ... */ 
            try {
                const response = await fetch('./char_mappings.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for char_mappings.json`);
                const mappings = await response.json();
                charToIndex = mappings.char_to_index; indexToChar = mappings.index_to_char;
                modelSequenceLength = mappings.sequence_length; modelVocabSize = mappings.vocab_size;
                console.log("Character mappings loaded successfully.");
                if (!charToIndex || !indexToChar || !modelSequenceLength || !modelVocabSize) throw new Error("Character mapping data incomplete.");
            } catch (error) { console.error("Could not load char_mappings.json:", error); modelStatusText.textContent = "Model: CharMap Error"; tfModelLoaded = false; }
        }
        async function loadTFModel() { /* ... (implementation unchanged) ... */ 
            if (Object.keys(charToIndex).length === 0) { modelStatusText.textContent = "Model: Not Loaded (No CharMap)"; return; }
            modelStatusText.textContent = "Model: Loading...";
            try {
                tfModel = await tf.loadLayersModel('./tfjs_model_output_directory/model.json');
                tfModelLoaded = true; modelStatusText.textContent = "Model: Loaded"; console.log("TF.js model loaded.");
                if (tfModel && modelSequenceLength > 0 && modelVocabSize > 0) {
                    console.log("Warming up model...");
                    const dummyInput = tf.tensor2d([new Array(modelSequenceLength).fill(0)], [1, modelSequenceLength], 'int32');
                    tfModel.predict(dummyInput).dispose(); dummyInput.dispose(); console.log("Model warmed up.");
                }
            } catch (error) { console.error("Error loading TF.js model:", error); modelStatusText.textContent = "Model: Error loading"; tfModelLoaded = false; }
        }
        async function getTFModelSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!tfModelLoaded || !tfModel || !prefix || prefix.length === 0 || Object.keys(charToIndex).length === 0) return [];
            let currentGeneratedSequence = prefix.toLowerCase();
            const modelSuggestionsOutput = new Set();
            try {
                for (let i = 0; i < 7 && modelSuggestionsOutput.size < MAX_SUGGESTIONS ; i++) {
                    let inputChars = currentGeneratedSequence.slice(-modelSequenceLength).split('');
                    let inputIds = inputChars.map(char => charToIndex[char] || 0);
                    while (inputIds.length < modelSequenceLength) inputIds.unshift(0);
                    const inputTensor = tf.tensor2d([inputIds], [1, modelSequenceLength], 'int32');
                    let predictionTensor;
                    try {
                        predictionTensor = tfModel.predict(inputTensor);
                        const probabilities = await predictionTensor.data();
                        let predictedIndex = 0, maxProb = -1;
                        for (let j = 0; j < probabilities.length; j++) if (probabilities[j] > maxProb) { maxProb = probabilities[j]; predictedIndex = j; }
                        const predictedChar = indexToChar[predictedIndex];
                        if (!predictedChar || predictedChar === ' ') {
                            const potentialWord = currentGeneratedSequence.toUpperCase();
                            if (potentialWord.length > prefix.length && (BASE_WORD_LIST.includes(potentialWord) || PERSONALIZED_WORD_LIST[potentialWord])) modelSuggestionsOutput.add(potentialWord);
                            break;
                        }
                        currentGeneratedSequence += predictedChar;
                        const fullPotentialWord = currentGeneratedSequence.toUpperCase();
                        if (fullPotentialWord.length > prefix.length && (BASE_WORD_LIST.includes(fullPotentialWord) || PERSONALIZED_WORD_LIST[fullPotentialWord])) modelSuggestionsOutput.add(fullPotentialWord);
                        if (i === 0 && currentGeneratedSequence.length === prefix.length + 1) {
                            const shortCompletion = currentGeneratedSequence.toUpperCase();
                            if (BASE_WORD_LIST.includes(shortCompletion) || PERSONALIZED_WORD_LIST[shortCompletion]) modelSuggestionsOutput.add(shortCompletion);
                        }
                    } finally { inputTensor.dispose(); if (predictionTensor) predictionTensor.dispose(); }
                }
                return Array.from(modelSuggestionsOutput).map(text => ({ text, source: 'model' }));
            } catch (error) { console.error("Error during TF model prediction:", error); return []; }
        }
        async function loadWordLists() { /* ... (implementation unchanged) ... */ 
            try {
                const storedPersonalizedWords = localStorage.getItem('personalizedWordList');
                PERSONALIZED_WORD_LIST = storedPersonalizedWords ? JSON.parse(storedPersonalizedWords) : {};
            } catch (e) { PERSONALIZED_WORD_LIST = {}; }
            try {
                const response = await fetch('./common_words.txt');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const text = await response.text();
                BASE_WORD_LIST = text.split(/\r?\n/).map(word => word.trim().toUpperCase()).filter(word => word.length > 0);
                if (BASE_WORD_LIST.length === 0) BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS];
            } catch (error) { BASE_WORD_LIST = [...DEFAULT_FALLBACK_WORDS]; }
        }
        function savePersonalizedWords() { /* ... (implementation unchanged) ... */ 
            try { localStorage.setItem('personalizedWordList', JSON.stringify(PERSONALIZED_WORD_LIST)); } 
            catch (e) { console.error("Error saving personalized words:", e); }
        }
        function learnWord(word) { /* ... (implementation unchanged) ... */ 
            if (!word || typeof word !== 'string' || word.length === 0) return;
            const upperWord = word.trim().toUpperCase();
            if (upperWord.length < 2 && !["A", "I"].includes(upperWord)) return;
            PERSONALIZED_WORD_LIST[upperWord] = (PERSONALIZED_WORD_LIST[upperWord] || 0) + 1;
            savePersonalizedWords();
        }

        // --- Audio & EAR Calculation ---
        function initAudio() { /* ... (implementation unchanged) ... */ 
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        function playSound(type = "key_action") { /* ... (implementation unchanged) ... */ 
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                oscillator.type = 'square';
                let freq = 440; 
                if (type === "calibration_blink") freq = 660;
                else if (type === "calibration_done") freq = 880;
                else if (type === "row_select") freq = 330;
                else if (type === "suggestion_select") freq = 550;
                else if (type === "special_key_select") freq = 380; 
                else if (type === "special_char_select") freq = 480; 
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                oscillator.start(); oscillator.stop(audioCtx.currentTime + 0.15);
            } catch (e) { console.error("Error playing sound:", type, e); }
        }
        function calculateDistance(p1, p2) { /* ... (implementation unchanged) ... */ 
            if (!p1 || !p2 || p1.x === undefined || p2.x === undefined) return 0.0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        function calculateEAR(eyeLandmarks) { /* ... (implementation unchanged) ... */ 
            if (!eyeLandmarks || eyeLandmarks.length !== 6) return 0.6; 
            for(let lm of eyeLandmarks) if(!lm || lm.x === undefined || lm.y === undefined) return 0.6;
            const v1 = calculateDistance(eyeLandmarks[1], eyeLandmarks[5]);
            const v2 = calculateDistance(eyeLandmarks[2], eyeLandmarks[4]);
            const h1 = calculateDistance(eyeLandmarks[0], eyeLandmarks[3]);
            return h1 <= 1e-6 ? 0.6 : (v1 + v2) / (2.0 * h1);
        }

        // --- Keyboard Layout & Highlighting ---
        function generateKeyboardLayout() { /* ... (implementation unchanged, uses updated constants) ... */ 
            keyboardRows = []; 
            keyboardArea.innerHTML = ''; 
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
            let letterIdx = 0;

            for (let r = 0; r < NUM_ALPHABET_ROWS; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row'; rowDiv.id = `kb-row-${r}`;
                let currentLayoutRow = [];
                for (let i = 0; i < KEYS_PER_ALPHABET_ROW; i++) {
                    if (letterIdx < 24) { 
                        const char = letters[letterIdx++];
                        const keyDiv = document.createElement('div'); keyDiv.className = 'key'; keyDiv.id = `key-${r}-${i}`; keyDiv.textContent = char;
                        rowDiv.appendChild(keyDiv); currentLayoutRow.push({ char: char, element: keyDiv, row: r, col: i });
                    }
                }
                keyboardRows.push(currentLayoutRow); keyboardArea.appendChild(rowDiv);
            }

            const row4Div = document.createElement('div'); row4Div.className = 'keyboard-row'; row4Div.id = `kb-row-${NUM_ALPHABET_ROWS}`;
            let row4Layout = [];
            const row4KeyDefinitions = [
                { char: letters[24], display: letters[24], classList: 'key' }, 
                { char: letters[25], display: letters[25], classList: 'key' }, 
                { char: NUM_KEY_CHAR, display: NUM_KEY_CHAR, classList: 'key special-key' }, // Display will be "Num"
                { char: PUNC_KEY_CHAR, display: PUNC_KEY_CHAR, classList: 'key special-key' }, // Display will be "[,.]"
                { char: SPACE_KEY_CHAR, display: SPACE_KEY_DISPLAY_TEXT, classList: 'key' }, 
                { char: BACKSPACE_KEY_CHAR, display: BACKSPACE_KEY_CHAR, classList: 'key special-key backspace-key' }
            ];
            row4KeyDefinitions.forEach((keyDef, i) => {
                const keyDiv = document.createElement('div'); keyDiv.className = keyDef.classList; keyDiv.id = `key-${NUM_ALPHABET_ROWS}-${i}`; keyDiv.textContent = keyDef.display;
                row4Div.appendChild(keyDiv); row4Layout.push({ char: keyDef.char, element: keyDiv, row: NUM_ALPHABET_ROWS, col: i });
            });
            keyboardRows.push(row4Layout); keyboardArea.appendChild(row4Div);

            const row5Div = document.createElement('div'); row5Div.className = 'keyboard-row'; row5Div.id = `kb-row-${NUM_ALPHABET_ROWS + 1}`;
            let row5Layout = [];
            SPECIAL_KEYS_FINAL_ROW_CHARS.forEach((char, i) => { // Will use "Suggest", "Search", "DEL", "CNCL"
                const keyDiv = document.createElement('div'); keyDiv.className = 'key special-key final-row-key'; keyDiv.id = `key-${NUM_ALPHABET_ROWS + 1}-${i}`; keyDiv.textContent = char;
                row5Div.appendChild(keyDiv); row5Layout.push({ char: char, element: keyDiv, row: NUM_ALPHABET_ROWS + 1, col: i });
            });
            keyboardRows.push(row5Layout); keyboardArea.appendChild(row5Div);
        }
        function displaySpecialKeyboard(layoutConfig) { /* ... (implementation unchanged) ... */ 
            keyboardArea.innerHTML = ''; 
            specialKeyboardRowElements = []; 
            activeSpecialKeyboardType = layoutConfig.type;

            const rowDiv = document.createElement('div');
            rowDiv.className = 'keyboard-row';
            rowDiv.id = `kb-special-row-${layoutConfig.type}`;

            layoutConfig.chars.forEach((char, i) => {
                const keyDiv = document.createElement('div');
                keyDiv.className = `key ${layoutConfig.type}-key`; 
                keyDiv.id = `key-special-${layoutConfig.type}-${i}`;
                keyDiv.textContent = char;
                rowDiv.appendChild(keyDiv);
                specialKeyboardRowElements.push({ char: char, element: keyDiv, row: 0, col: i });
            });

            const cancelKeyDiv = document.createElement('div');
            cancelKeyDiv.className = 'key special-key'; 
            cancelKeyDiv.id = `key-special-${layoutConfig.type}-cancel`;
            cancelKeyDiv.textContent = CANCEL_KEY_CHAR;
            rowDiv.appendChild(cancelKeyDiv);
            specialKeyboardRowElements.push({ char: CANCEL_KEY_CHAR, element: cancelKeyDiv, row: 0, col: layoutConfig.chars.length });

            keyboardArea.appendChild(rowDiv);
            lastTraversalTime = performance.now(); 
            currentKeyScanIndexInRow = 0; 
            updateKeyboardHighlight(); 
        }
        function updateKeyboardHighlight() { /* ... (implementation unchanged) ... */ 
            document.querySelectorAll('.key.highlighted, .key.selection-pending, .key.cancel-option-pending, .keyboard-row.row-highlighted, .keyboard-row.selection-pending')
                .forEach(el => el.classList.remove('highlighted', 'selection-pending', 'cancel-option-pending', 'row-highlighted'));
            suggestionsArea.querySelectorAll('.suggestion.highlighted, .suggestion.selection-pending')
                .forEach(sugg => sugg.classList.remove('highlighted', 'selection-pending'));

            if (isCalibrating || !initialDelayPassed || isPausedAfterSelection) return;

            let elementToMark = null;
            let suggestionSource = null; 
            let isCancelForMainKeyboard = false; 

            if (currentScanMode === SCANNING_MODE_ROW) {
                if (keyboardRows[currentRowScanIndex]) {
                    const rowDiv = document.getElementById(`kb-row-${currentRowScanIndex}`);
                    if (rowDiv) rowDiv.classList.add(isTraversalPausedForSelectionConsideration ? 'selection-pending' : 'row-highlighted');
                }
            } else if (currentScanMode === SCANNING_MODE_KEY) { 
                if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                    elementToMark = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].element;
                    if (isOfferingKeyScanCancel && keyboardRows[selectedRowIndex][currentKeyScanIndexInRow].char === CANCEL_KEY_CHAR) {
                        isCancelForMainKeyboard = true; 
                    }
                }
            } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                const suggestions = suggestionsArea.querySelectorAll('.suggestion');
                if (activeSuggestionListForScanning?.[currentSuggestionIndex]) {
                    elementToMark = suggestions[currentSuggestionIndex];
                    suggestionSource = activeSuggestionListForScanning[currentSuggestionIndex].source;
                }
            } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) { 
                if (specialKeyboardRowElements[currentKeyScanIndexInRow]) {
                    elementToMark = specialKeyboardRowElements[currentKeyScanIndexInRow].element;
                }
            }

            if (elementToMark) {
                if (isCancelForMainKeyboard) { 
                    elementToMark.classList.add('cancel-option-pending');
                } else if (isTraversalPausedForSelectionConsideration) {
                    elementToMark.classList.add('selection-pending');
                } else {
                    elementToMark.classList.add('highlighted');
                }
                if (suggestionSource === 'personalized') elementToMark.classList.add('personalized');
                else if (suggestionSource === 'model') elementToMark.classList.add('model-prediction');
            }
        }

        // --- Suggestions Logic ---
        function getPersonalizedSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            return Object.entries(PERSONALIZED_WORD_LIST)
                .filter(([word]) => word.toLowerCase().startsWith(prefixLower))
                .map(([text, frequency]) => ({ text, frequency, source: 'personalized' })) 
                .sort((a, b) => b.frequency - a.frequency);
        }
        async function getCombinedSuggestions(prefix) { /* ... (implementation unchanged) ... */ 
            if (!prefix) return [];
            const prefixLower = prefix.toLowerCase();
            let combined = [];
            const addedTexts = new Set(); 

            const personalized = getPersonalizedSuggestions(prefixLower);
            personalized.forEach(sugg => {
                if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                    combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                }
            });

            if (combined.length < MAX_SUGGESTIONS && tfModelLoaded) {
                const modelSuggestions = await getTFModelSuggestions(prefixLower); 
                modelSuggestions.forEach(sugg => {
                    if (combined.length < MAX_SUGGESTIONS && !addedTexts.has(sugg.text.toLowerCase())) {
                        combined.push(sugg); addedTexts.add(sugg.text.toLowerCase());
                    }
                });
            }
            
            if (combined.length < MAX_SUGGESTIONS) {
                for (const word of BASE_WORD_LIST) {
                    if (combined.length >= MAX_SUGGESTIONS) break;
                    if (word.toLowerCase().startsWith(prefixLower) && !addedTexts.has(word.toLowerCase())) {
                        combined.push({ text: word, source: 'base' }); addedTexts.add(word.toLowerCase());
                    }
                }
            }
            return combined.slice(0, MAX_SUGGESTIONS); 
        }
        function displaySuggestions() { /* ... (implementation unchanged) ... */ 
            suggestionsArea.innerHTML = '';
            const listToDisplay = (currentScanMode === SCANNING_MODE_SUGGESTION) ? activeSuggestionListForScanning : currentSuggestionObjects;
            if (!listToDisplay || listToDisplay.length === 0) {
                suggestionsArea.innerHTML = ''; updateKeyboardHighlight(); return;
            }
            listToDisplay.forEach(suggObj => {
                const suggDiv = document.createElement('div'); suggDiv.className = 'suggestion';
                suggDiv.textContent = suggObj.text; 
                if (suggObj.source === 'personalized') suggDiv.classList.add('personalized');
                else if (suggObj.source === 'model') suggDiv.classList.add('model-prediction');
                suggestionsArea.appendChild(suggDiv);
            });
            updateKeyboardHighlight(); 
        }

        // --- Core Scanning Logic & State Management ---
        function resetToRowScan() { /* ... (implementation unchanged) ... */ 
            currentScanMode = SCANNING_MODE_ROW;
            currentRowScanIndex = 0;
            selectedRowIndex = -1;
            originalSelectedRowForKeyScan = -1;
            currentKeyScanIndexInRow = 0; 
            activeSuggestionListForScanning = [];
            currentSuggestionIndex = 0;
            lastTraversalTime = performance.now();
            isTraversalPausedForSelectionConsideration = false;
            isOfferingKeyScanCancel = false;
            eyeClosureFramesCount = 0;
            statusText.textContent = "Status: Row Scanning";
            displaySuggestions(); 
            updateKeyboardHighlight(); 
        }
        function resetAndDisplayMainKeyboard() { /* ... (implementation unchanged) ... */ 
            activeSpecialKeyboardType = null;
            specialKeyboardRowElements = [];
            generateKeyboardLayout();    
            resetToRowScan();            
        }
        function handleCalibration(avgEar) { /* ... (implementation unchanged) ... */ 
            if (!isCalibrating) return false; 

            calibrationInstructions.style.display = 'block';
            loadingMessage.textContent = `Calibrating: ${calibrationBlinksNeeded} blink(s) remaining.`;
            eyeStatusText.textContent = `EAR: ${avgEar.toFixed(2)} (Calibrating)`;

            if (calibrationState === "idle") {
                if (avgEar < INITIAL_EAR_FOR_CALIBRATION_DETECTION) {
                    calibrationState = "detecting_low";
                    calibrationFramesLowCount = 1;
                    currentCalibrationBlinkMinEar = avgEar; 
                }
            } else if (calibrationState === "detecting_low") {
                if (avgEar < INITIAL_EAR_FOR_CALIBRATION_DETECTION) {
                    calibrationFramesLowCount++;
                    if (avgEar < currentCalibrationBlinkMinEar) {
                        currentCalibrationBlinkMinEar = avgEar;
                    }
                } else { 
                    if (calibrationFramesLowCount >= CALIBRATION_BLINK_MIN_FRAMES_LOW) {
                        calibrationState = "detecting_high";
                        calibrationFramesHighCount = 1;
                    } else { 
                        calibrationState = "idle";
                        calibrationFramesLowCount = 0;
                        currentCalibrationBlinkMinEar = 1.0;
                    }
                }
            } else if (calibrationState === "detecting_high") {
                if (avgEar > INITIAL_EAR_FOR_CALIBRATION_DETECTION) { 
                    calibrationFramesHighCount++;
                    if (calibrationFramesHighCount >= CALIBRATION_BLINK_MIN_FRAMES_HIGH) {
                        
                        calibrationEarValues.push(currentCalibrationBlinkMinEar);
                        calibrationBlinksNeeded--;
                        playSound("calibration_blink");
                        loadingMessage.textContent = `Blink ${3 - calibrationBlinksNeeded} registered! Min EAR: ${currentCalibrationBlinkMinEar.toFixed(2)}. ${calibrationBlinksNeeded} more.`;
                        console.log(`Calibration blink ${3-calibrationBlinksNeeded} detected. Min EAR: ${currentCalibrationBlinkMinEar}`);

                        calibrationState = "idle";
                        calibrationFramesLowCount = 0;
                        calibrationFramesHighCount = 0;
                        currentCalibrationBlinkMinEar = 1.0;

                        if (calibrationBlinksNeeded === 0) {
                            if (calibrationEarValues.length > 0) {
                                const sumEar = calibrationEarValues.reduce((sum, val) => sum + val, 0);
                                const avgCalibratedEar = sumEar / calibrationEarValues.length;
                                minEarThreshold = avgCalibratedEar + (0.30 - avgCalibratedEar) * 0.5; 
                                if (minEarThreshold > 0.35) minEarThreshold = 0.35; 
                                if (minEarThreshold < 0.15) minEarThreshold = 0.15; 

                                playSound("calibration_done");
                                loadingMessage.textContent = `Calibration complete! New EAR Threshold: ${minEarThreshold.toFixed(2)}`;
                                console.log(`Calibration complete. Values: ${calibrationEarValues.join(', ')}. Average Min: ${avgCalibratedEar.toFixed(2)}. New Threshold: ${minEarThreshold.toFixed(2)}`);
                            } else {
                                minEarThreshold = 0.25; 
                                loadingMessage.textContent = "Calibration failed to get values, using default threshold.";
                                console.warn("Calibration completed with no EAR values, using default.");
                            }
                            isCalibrating = false;
                            calibrationInstructions.style.display = 'none';
                            startTime = performance.now();
                            initialDelayPassed = false;
                            statusText.textContent = "Status: Initializing keyboard...";
                            resetAndDisplayMainKeyboard(); 
                            return true; 
                        }
                    }
                } else { 
                    calibrationState = "detecting_low"; 
                }
            }
            return true; 
        }

        function onResults(results) { /* ... (implementation largely unchanged) ... */ 
            const currentTime = performance.now();
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            let selectionTriggeredThisFrame = false;
            let avgEar = 0.6;

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const leftEyeLms = LEFT_EYE_INDICES.map(i => landmarks[i]);
                const rightEyeLms = RIGHT_EYE_INDICES.map(i => landmarks[i]);
                avgEar = (calculateEAR(leftEyeLms) + calculateEAR(rightEyeLms)) / 2.0;

                if (isCalibrating) {
                    if (handleCalibration(avgEar)) { canvasCtx.restore(); return; }
                }

                eyeStatusText.textContent = `EAR: ${avgEar.toFixed(2)}${isTraversalPausedForSelectionConsideration ? ` (Paused - ${eyeClosureFramesCount})` : ""}`;

                if (avgEar < minEarThreshold) {
                    if (initialDelayPassed && !isPausedAfterSelection) {
                        isTraversalPausedForSelectionConsideration = true; eyeClosureFramesCount++;
                    }
                } else {
                    if (isTraversalPausedForSelectionConsideration) {
                        if (eyeClosureFramesCount >= SELECTION_BLINK_MIN_FRAMES) {
                            if (!isPausedAfterSelection && initialDelayPassed) selectionTriggeredThisFrame = true;
                        }
                        eyeClosureFramesCount = 0; isTraversalPausedForSelectionConsideration = false;
                    }
                }
            } else {
                if (isCalibrating) { loadingMessage.textContent = "Calibrating: No face detected."; }
                eyeStatusText.textContent = "EAR: N/A (No face detected)";
                eyeClosureFramesCount = 0; isTraversalPausedForSelectionConsideration = false;
                if (currentScanMode === SCANNING_MODE_KEY && isOfferingKeyScanCancel) {
                    isOfferingKeyScanCancel = false; resetAndDisplayMainKeyboard(); 
                } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) {
                    resetAndDisplayMainKeyboard();
                }
            }

            if (isPausedAfterSelection && (currentTime - lastSelectionTime) / 1000 >= POST_SELECTION_PAUSE) {
                isPausedAfterSelection = false; lastTraversalTime = currentTime;
            }

            if (!isCalibrating && !initialDelayPassed) {
                const elapsed = (currentTime - startTime) / 1000;
                statusText.textContent = `Status: Initializing... (${(INITIAL_DELAY - elapsed).toFixed(1)}s)`;
                if (elapsed >= INITIAL_DELAY) { initialDelayPassed = true; lastTraversalTime = currentTime; resetToRowScan(); } 
            } else if (!isCalibrating && !isPausedAfterSelection) {
                if (selectionTriggeredThisFrame) {
                    lastSelectionTime = currentTime; isPausedAfterSelection = true;
                    isTraversalPausedForSelectionConsideration = false; eyeClosureFramesCount = 0;

                    if (currentScanMode === SCANNING_MODE_ROW) {
                        if (keyboardRows[currentRowScanIndex]) {
                            selectedRowIndex = currentRowScanIndex; originalSelectedRowForKeyScan = currentRowScanIndex;
                            currentScanMode = SCANNING_MODE_KEY; currentKeyScanIndexInRow = 0;
                            isOfferingKeyScanCancel = false;
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; playSound("row_select");
                        }
                    } else if (currentScanMode === SCANNING_MODE_KEY) { 
                        if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex]?.[currentKeyScanIndexInRow]) {
                            const keyInfo = keyboardRows[selectedRowIndex][currentKeyScanIndexInRow];
                            const char = keyInfo.char;
                            let wordToLearn = null;

                            if (isOfferingKeyScanCancel && char === CANCEL_KEY_CHAR) {
                                playSound("key_action"); resetAndDisplayMainKeyboard();
                            } else {
                                isOfferingKeyScanCancel = false;
                                if (char === NUM_KEY_CHAR) {
                                    playSound("special_key_select");
                                    displaySpecialKeyboard(NUMBERS_LAYOUT_CONFIG);
                                    currentScanMode = SCANNING_MODE_SPECIAL_ROW;
                                    statusText.textContent = "Status: Number Input";
                                } else if (char === PUNC_KEY_CHAR) {
                                    playSound("special_key_select");
                                    displaySpecialKeyboard(PUNCTUATION_LAYOUT_CONFIG);
                                    currentScanMode = SCANNING_MODE_SPECIAL_ROW;
                                    statusText.textContent = "Status: Punctuation Input";
                                } else { 
                                    playSound("key_action");
                                    if (char === BACKSPACE_KEY_CHAR) { typedText = typedText.slice(0, -1); }
                                    else if (char === SPACE_KEY_CHAR) { const w = typedText.trim().split(/\s+/); if (w.length > 0 && w[w.length-1]) wordToLearn = w[w.length-1]; typedText += " "; }
                                    else if (char === SEARCH_KEY_CHAR) { if (typedText) window.open(`https://www.google.com/search?q=${encodeURIComponent(typedText)}`, '_blank');}
                                    else if (char === DELETE_KEY_CHAR) { const ls = typedText.trimEnd().lastIndexOf(' '); typedText = (ls !== -1) ? typedText.substring(0, ls + 1) : "";}
                                    else if (char === SUGGEST_KEY_CHAR) {
                                        activeSuggestionListForScanning = [...currentSuggestionObjects];
                                        activeSuggestionListForScanning.push({text: SUGGESTION_SKIP_TEXT, source: 'system'});
                                        currentScanMode = SCANNING_MODE_SUGGESTION; currentSuggestionIndex = 0;
                                        statusText.textContent = "Status: Suggestion Scanning"; displaySuggestions();
                                    } else if (char !== CANCEL_KEY_CHAR) { 
                                        typedText += char;
                                    }

                                    if (char !== SUGGEST_KEY_CHAR) { 
                                       if (char === SPACE_KEY_CHAR || char === BACKSPACE_KEY_CHAR || char === DELETE_KEY_CHAR || (char !== CANCEL_KEY_CHAR && char !== SEARCH_KEY_CHAR) ) {
                                            const prefix = typedText.match(/([^\s]+)$/)?.[0] || ""; 
                                            getCombinedSuggestions(prefix).then(suggestions => {
                                                currentSuggestionObjects = suggestions; displaySuggestions();
                                            }).catch(err => { currentSuggestionObjects = []; displaySuggestions();});
                                        } else { 
                                            currentSuggestionObjects = []; displaySuggestions();
                                        }
                                        resetAndDisplayMainKeyboard(); 
                                    }
                                    if(wordToLearn) learnWord(wordToLearn);
                                    typedTextArea.textContent = typedText;
                                    if (char !== SUGGEST_KEY_CHAR) statusText.textContent = `Action: ${keyInfo.element.textContent}`;
                                }
                            }
                        } else { resetAndDisplayMainKeyboard(); }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                        if (activeSuggestionListForScanning?.[currentSuggestionIndex]) {
                            const item = activeSuggestionListForScanning[currentSuggestionIndex].text; playSound("suggestion_select");
                            if (item !== SUGGESTION_SKIP_TEXT) {
                                const ls = typedText.lastIndexOf(' '); typedText = (ls === -1 ? "" : typedText.substring(0, ls + 1)) + item + " ";
                                typedTextArea.textContent = typedText; learnWord(item);
                            } statusText.textContent = `Suggestion: ${item}`;
                            currentSuggestionObjects = []; 
                            resetAndDisplayMainKeyboard(); 
                        } else { resetAndDisplayMainKeyboard(); }
                    } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) {
                        if (specialKeyboardRowElements[currentKeyScanIndexInRow]) {
                            const keyInfo = specialKeyboardRowElements[currentKeyScanIndexInRow];
                            const char = keyInfo.char;
                            playSound("special_char_select");
                            if (char === CANCEL_KEY_CHAR) {
                                // Do nothing
                            } else {
                                typedText += char;
                                typedTextArea.textContent = typedText;
                                const prefix = typedText.match(/([^\s]+)$/)?.[0] || "";
                                getCombinedSuggestions(prefix).then(suggestions => {
                                    currentSuggestionObjects = suggestions; 
                                }).catch(err => { currentSuggestionObjects = [];});
                            }
                            resetAndDisplayMainKeyboard(); 
                        } else { resetAndDisplayMainKeyboard(); }
                    }
                } else if (!isTraversalPausedForSelectionConsideration && (currentTime - lastTraversalTime) / 1000 >= TRAVERSAL_INTERVAL) { 
                    if (currentScanMode === SCANNING_MODE_ROW) {
                        currentRowScanIndex = (currentRowScanIndex + 1) % keyboardRows.length;
                        statusText.textContent = "Status: Row Scanning";
                    } else if (currentScanMode === SCANNING_MODE_KEY) {
                        if (isOfferingKeyScanCancel) {
                            isOfferingKeyScanCancel = false; selectedRowIndex = originalSelectedRowForKeyScan;
                            currentKeyScanIndexInRow = 0;
                            statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                        } else {
                            currentKeyScanIndexInRow++;
                            if (selectedRowIndex !== -1 && keyboardRows[selectedRowIndex] && currentKeyScanIndexInRow >= keyboardRows[selectedRowIndex].length) {
                                isOfferingKeyScanCancel = true; originalSelectedRowForKeyScan = selectedRowIndex;
                                selectedRowIndex = keyboardRows.length - 1; 
                                const cancelKeyObj = keyboardRows[selectedRowIndex].find(key => key.char === CANCEL_KEY_CHAR);
                                currentKeyScanIndexInRow = cancelKeyObj ? keyboardRows[selectedRowIndex].indexOf(cancelKeyObj) : 0;
                                statusText.textContent = "Status: Cancel Key Scan?";
                            } else if (selectedRowIndex == -1 || !keyboardRows[selectedRowIndex]) { resetAndDisplayMainKeyboard();
                            } else { statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`; }
                        }
                    } else if (currentScanMode === SCANNING_MODE_SUGGESTION) {
                        if (activeSuggestionListForScanning?.length > 0) currentSuggestionIndex = (currentSuggestionIndex + 1) % activeSuggestionListForScanning.length;
                        else { resetAndDisplayMainKeyboard(); } 
                        statusText.textContent = "Status: Suggestion Scanning";
                    } else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) {
                        currentKeyScanIndexInRow = (currentKeyScanIndexInRow + 1) % specialKeyboardRowElements.length;
                        statusText.textContent = `Status: ${activeSpecialKeyboardType === 'number' ? 'Number' : 'Punctuation'} Input`;
                    }
                    lastTraversalTime = currentTime;
                } else if (isTraversalPausedForSelectionConsideration && !statusText.textContent.includes("Evaluating")) {
                    statusText.textContent = "Status: Evaluating Blink...";
                } else if (!isCalibrating && !isTraversalPausedForSelectionConsideration && !isOfferingKeyScanCancel &&
                           !statusText.textContent.startsWith("Status: Initializing") &&
                           !statusText.textContent.startsWith("Action:") &&
                           !statusText.textContent.startsWith("Suggestion:")) {
                    if (currentScanMode === SCANNING_MODE_ROW) statusText.textContent = "Status: Row Scanning";
                    else if (currentScanMode === SCANNING_MODE_KEY && selectedRowIndex !== -1) statusText.textContent = `Status: Key Scanning (Row ${selectedRowIndex + 1})`;
                    else if (currentScanMode === SCANNING_MODE_SUGGESTION && activeSuggestionListForScanning?.length > 0) statusText.textContent = "Status: Suggestion Scanning";
                    else if (currentScanMode === SCANNING_MODE_SPECIAL_ROW) statusText.textContent = `Status: ${activeSpecialKeyboardType === 'number' ? 'Number' : 'Punctuation'} Input`;
                }
            }
            updateKeyboardHighlight();
            canvasCtx.restore();
        }

        // --- Application Initialization ---
        async function startApp() {
            stopAutoStartTimer();
            isAutoStartPaused = false; 

            currentSuggestionIndex = 0; 
            await loadWordLists();
            await loadCharMappings();
            await loadTFModel();
            initAudio();
            startButton.disabled = true; startButton.textContent = "Loading...";
            loadingMessage.textContent = "Initializing MediaPipe..."; loadingMessage.style.display = 'block';
            calibrationInstructions.style.display = 'none';

            try {
                faceMesh = new FaceMesh({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                faceMesh.onResults(onResults);
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                };
                if (typeof Camera === "undefined") throw new Error("Camera utility not loaded from MediaPipe.");
                camera = new Camera(videoElement, {
                    onFrame: async () => { if (videoElement.readyState >= 2) { await faceMesh.send({image: videoElement}); } },
                    width: FRAME_WIDTH, height: FRAME_HEIGHT
                });
                await camera.start();
                if (videoElement.videoWidth > 0 && (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight) ) {
                    canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
                }

                isCalibrating = true;
                calibrationBlinksNeeded = 3; calibrationEarValues = []; calibrationState = "idle";
                calibrationFramesLowCount = 0; calibrationFramesHighCount = 0; currentCalibrationBlinkMinEar = 1.0;
                loadingMessage.textContent = "Camera started. Calibrating...";
                calibrationInstructions.textContent = "Please look at the camera and blink SLOWLY three times when your eyes feel normal.";
                calibrationInstructions.style.display = 'block';
                statusText.textContent = "Status: Calibrating";

            } catch (err) {
                console.error("Error during startApp:", err);
                loadingMessage.textContent = `Error: ${err.message}. Check console & permissions.`;
                statusText.textContent = "Status: Error"; modelStatusText.textContent = "Model: Error";
                startButton.disabled = false; startButton.textContent = "Start Camera"; 
                isAutoStartPaused = false; 
                calibrationInstructions.style.display = 'none';
            }
        }

        // Event Listeners
        startButton.addEventListener('click', () => {
            if (isAutoStartActive) { 
                stopAutoStartTimer();
                isAutoStartPaused = true;
                startButton.textContent = "Start Camera (Paused)";
                loadingMessage.textContent = "Auto-start paused. Click button to start manually.";
            } else { 
                isAutoStartPaused = false; 
                startApp(); 
            }
        });

        window.addEventListener('load', () => {
            startAutoStartTimer(); 
        });

    </script>
</body>
</html>
